---
time: '1996-09-08T23:37:07+08:00'
id: 'dstgtes'
---

https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(object-oriented_programming)
# l-compiler

# l-dpendency
如何使用他人的库
1. 原理是什么
2. 如何增加/安装/使用一个库
4. 国内镜像(233)
## tips
1. 远程模型/本地模块?
2. 在局部作用域中暴露命名空间 (在一个函数内,引入某个模块的所有命名空间)
# doc
如何生成文档?如何在代码中书写文档
# l-test
如何测试

# l-io
## l-console-out
向控制台输出的能力
# l-interface
interface 对类或者对数据结构作出描述,而我们根据这种事先的约定/约束 操作数据,而不用关心具体的实现, Java中的interface,C++中的虚函数,Golang中的Interfact,Rust中trait,Ts中的interface
1. 如何定义interface 
2. 如何实现interface
## l-advance-interface
### l-interface-generic (范型)


# l-async
语法层次上的对于异步的支持

# 函数定义 ([[l-function]])
无论如何我们都需要某种机制让我们能够将逻辑/表达式 组合成一个上层的有语义的逻辑块,函数是第一层的封装.函数要素 1. 函数定义符 2. 函数名 3. 参数 4. 返回值
- go [v]
## 函数参数定义 (l-function-args)
有些语言允许同时定义多个元素的类型
- go [v]
- rust [x]
## tips (l-anonymous-function)
此外还有如何定义匿名函数,即闭包
## 函数默认参数 (l-function-default-argument)
## 函数可选参数 (l-function-option-argument)
# [[l-var-define]] (变量定义)
不同的语言中定义一个变量的姿势也不同
## l-var-define-var
## l-var-define-array
## l-var-define-hashmap
## l-var-define-object
## l-var-define-string

# l-type-define
基本上在所有的语言中都有有关数据类型的语法
我们该如何声明那些常见的数据类型？


# 结构体定义 (l-struct)
无论如何我们需要某种机制让我们能够将数据/类型 组合成一个有上层语义的数据/类型
## 构造结构体 (l-construct-struct)
## l-struct-mixin
组合结构体 最常见的一种是将一种类型的结构体作为另一种类型的结构体的一个fieled，当是还有种是将两个结构体merge起来,例如golang的struct mixute

## 匿名结构体 (l-struct-anonymous)
一些语言 类似golang允许我们定义一些匿名结构体

# l-statement
## l-select
根据条件判断执行某些语句.  
条件判断可以是简单的bool,也可能是模式匹配.  
执行语句可能是简单的执行一次,也可能是执行完成后再循环
### l-if/else
### l-loop
- go [v]
### iterator (与loop不同iterator更加强调遍历容器)

# l-common-container

# l-string
## l-string-raw
1. 无转义的原生字符 类似于 rust的`r#””“#`
2. 多行的字符串

## [[l-string-fmt]]
给定一些值，如何将其构造成字符串？ 一个常用的方法是以一个字符串为模板 将值应用进去从而得到新的字符串
不同的语言中字符串模板的写法均有所不同
JS中是[[js-template-strings]] 除了上述所讲外 还有一个概念叫做[[js-tagged-templates]],可以搞出更多的花样.
Python中是通过[[python-fstring]]
Rust中是通过常规的`"xxx".format(xxx)`的形式
## l-string-api
- compare-string-dict-order
## array
### l-array-access-syntax
对于顺序容器的一个常见操作是 1. 获取其中某个元素 2. 获取其中一段range的引用
一个常见的方法是使用`[]`操作符
获取其中某个元素 [x] 如果将x的类型从usize变为isize 我们可以很方便的表示从末尾开始的索引 如`[-1]`表示最后一个
range也是类似[1:3]表示从1-3的这一range [1,-1]表示从index为1的到最后一个
有些语言如python中还允许你选择step


#### l-array-index
#### l-array-range
最起码就golang和rust而言array-range的模型是统一的
1. 前闭后开
2. 当low,hight相等时返回空
3. low>hight报错
[x] golang 
[x] rust

## quque
## map


# l-scoop
有时我们希望作用域有返回值 这样一些操作就可以包装在一个嵌套的作用域中,这样可以将逻辑封装起来,使得阅读是每一步的抽象层次都是大致相当的.
[x] rust
[ ] golang

# l-assert
某些不可能发生的事情发生的时候 是我们不可能希望看到的 这时就要用assert 强制的作出约束


# l-env
例如当前代码文件 行号 等 环境信息 方便于debug

# l-dynamic-lanuange
## l-access-nest-object
在动态语言中 我们该如何如何正常(优雅而安全)的访问一个嵌套的object?

# l-profile
当检测内存泄漏时 最简单的方式就是定时对mem做快照 通过对比内存快照检测泄漏点
[go]


# l-json
对于JSON的支持 语言中的某个实例 <=>JSON 
# l-ffi
> 赞美C,你的ABI行走在世界的每个角落.
ffi 以某种方式调用其他语言的接口,或者提供接口被其他语言调用.当然了,在这个世界线上这种所谓的接口就是C的ABI.
## l-call-fii
对于FFI来讲 所有权应当控制在调用者手中 调用者来负责分配内存释放内存.
下面的echo就是一个很好的例子.写入参数/写出参数/返回值 全部齐全了.
```c
extern "C" int echo(char *OutBuffer, size_t &OutLen, const char *InBuffer, size_t InLen)
{
    std::memcpy(OutBuffer, InBuffer, InLen);
}
```
### l-call-ffi-dynmaic

### l-call-ffi-static

## l-been-ffi
必须能够变成动态或者静态的c库

### l-been-ffi-dynmaic

### l-been-ffi-static

## project template
使用此语言的最佳实践 各种项目的模板 如 cli,server,front server等
## l-language-formal-define
准确的语法定义 类似BNF这种

# l-concept-option-method
每个语言中都有一种标识契约的概念,通俗的来讲就是抽象类.  
在使用这种"抽象类"的时候.一个通俗的想法是抽象方法,子类或者其他什么"东西"可以通过"继承"来复用抽象类.在向下就是"option method",即抽象方法我们希望其有一个默认的实现,如果子类自己实现了就用子类的,没实现就用默认的,通俗的来讲就是某种hook手段.



# l-type-cast

# l-private-constructor
类拿回构造控制权的一种方式，不能随意的由外界构造

# l-module
## l-export
