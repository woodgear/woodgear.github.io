{"componentChunkName":"component---src-templates-blog-post-js","path":"/share/编程语言要素/语言要素/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(object-oriented_programming\">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(object-oriented_programming</a>)</p>\n<h1>l-dpendency</h1>\n<p>如何使用他人的库</p>\n<ol>\n<li>原理是什么</li>\n<li>如何增加/安装/使用一个库</li>\n<li>\n<p>国内镜像(233)</p>\n<h2>tips</h2>\n</li>\n<li>远程模型/本地模块?</li>\n<li>\n<p>在局部作用域中暴露命名空间 (在一个函数内,引入某个模块的所有命名空间)</p>\n<h1>doc</h1>\n<p>如何生成文档?如何在代码中书写文档</p>\n<h1>l-test</h1>\n<p>如何测试</p>\n</li>\n</ol>\n<h1>l-io</h1>\n<h2>l-console-out</h2>\n<p>向控制台输出的能力</p>\n<h1>l-interface</h1>\n<p>interface 对类或者对数据结构作出描述,而我们根据这种事先的约定/约束 操作数据,而不用关心具体的实现, Java中的interface,C++中的虚函数,Golang中的Interfact,Rust中trait,Ts中的interface</p>\n<ol>\n<li>如何定义interface </li>\n<li>\n<p>如何实现interface</p>\n<h2>l-advance-interface</h2>\n<h3>l-interface-generic (范型)</h3>\n</li>\n</ol>\n<h1>l-async</h1>\n<p>语法层次上的对于异步的支持</p>\n<h1>函数定义 (l-function)</h1>\n<p>无论如何我们都需要某种机制让我们能够将逻辑/表达式 组合成一个上层的有语义的逻辑块,函数是第一层的封装.函数要素 1. 函数定义符 2. 函数名 3. 参数 4. 返回值</p>\n<ul>\n<li>\n<p>go [v]</p>\n<h2>函数参数定义 (l-function-args)</h2>\n<p>有些语言允许同时定义多个元素的类型</p>\n</li>\n<li>go [v]</li>\n<li>\n<p>rust [x]</p>\n<h2>tips (l-anonymous-function)</h2>\n<p>此外还有如何定义匿名函数,即闭包</p>\n</li>\n</ul>\n<h1>l-var-define (变量定义)</h1>\n<p>不同的语言中定义一个变量的姿势也不同</p>\n<h2>l-var-define-var</h2>\n<h2>l-var-define-array</h2>\n<h2>l-var-define-hashmap</h2>\n<h2>l-var-define-object</h2>\n<h2>l-var-define-string</h2>\n<h1>结构体定义 (l-struct)</h1>\n<p>无论如何我们需要某种机制让我们能够将数据/类型 组合成一个有上层语义的数据/类型</p>\n<h2>构造结构体 (l-construct-struct)</h2>\n<h2>l-struct-mixin</h2>\n<p>组合结构体 最常见的一种是将一种类型的结构体作为另一种类型的结构体的一个fieled，当是还有种是将两个结构体merge起来,例如golang的struct mixute</p>\n<h1>l-statement</h1>\n<h2>l-select</h2>\n<p>根据条件判断执行某些语句.<br>\n条件判断可以是简单的bool,也可能是模式匹配.<br>\n执行语句可能是简单的执行一次,也可能是执行完成后再循环</p>\n<h3>l-if/else</h3>\n<h3>l-loop</h3>\n<ul>\n<li>\n<p>go [v]</p>\n<h3>iterator (与loop不同iterator更加强调遍历容器)</h3>\n</li>\n</ul>\n<h1>l-common-container</h1>\n<h1>l-string</h1>\n<h2>l-string-fmt</h2>\n<p>给定一些值，如何将其构造成字符串？ 一个常用的方法是以一个字符串为模板 将值应用进去从而得到新的字符串\n不同的语言中字符串模板的写法均有所不同</p>\n<h2>l-string-api</h2>\n<ul>\n<li>\n<p>compare-string-dict-order</p>\n<h2>array</h2>\n<h3>l-array-access-syntax</h3>\n<p>对于顺序容器的一个常见操作是 1. 获取其中某个元素 2. 获取其中一段range的引用\n一个常见的方法是使用<code class=\"language-text\">[]</code>操作符\n获取其中某个元素 [x] 如果将x的类型从usize变为isize 我们可以很方便的表示从末尾开始的索引 如<code class=\"language-text\">[-1]</code>表示最后一个\nrange也是类似[1:3]表示从1-3的这一range [1,-1]表示从index为1的到最后一个\n有些语言如python中还允许你选择step</p>\n</li>\n</ul>\n<h4>l-array-index</h4>\n<h4>l-array-range</h4>\n<p>最起码就golang和rust而言array-range的模型是统一的</p>\n<ol>\n<li>前闭后开</li>\n<li>当low,hight相等时返回空</li>\n<li>low>hight报错\n[x] golang\n[x] rust</li>\n</ol>\n<h2>quque</h2>\n<h2>map</h2>\n<h1>l-scoop</h1>\n<p>有时我们希望作用域有返回值 这样一些操作就可以包装在一个嵌套的作用域中,这样可以将逻辑封装起来,使得阅读是每一步的抽象层次都是大致相当的.\n[x] rust\n[ ] golang</p>\n<h1>l-assert</h1>\n<p>某些不可能发生的事情发生的时候 是我们不可能希望看到的 这时就要用assert 强制的作出约束</p>\n<h1>l-env</h1>\n<p>例如当前代码文件 行号 等 环境信息 方便于debug</p>\n<h1>l-dynamic-lanuange</h1>\n<h2>l-access-nest-object</h2>\n<p>在动态语言中 我们该如何如何正常(优雅而安全)的访问一个嵌套的object?</p>\n<h1>l-profile</h1>\n<p>当检测内存泄漏时 最简单的方式就是定时对mem做快照 通过对比内存快照检测泄漏点\n[go]</p>"}},"pageContext":{"slug":"/share/编程语言要素/语言要素/"}}}