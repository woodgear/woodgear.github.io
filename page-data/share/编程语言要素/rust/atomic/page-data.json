{"componentChunkName":"component---src-templates-blog-post-js","path":"/share/编程语言要素/rust/atomic/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://doc.rust-lang.org/nomicon/atomics.html\">原子类型</a><br>\n我们可以放心的多线程环境中使用原子类型 但是很明显的要赋予其面对多线程访问时如何处理的信息 </p>\n<h2>Sequentially Consistent (SeqCst)</h2>\n<p>all accesses on one thread that happen before and after a SeqCst access stay before and after it<br>\n序列固化是的编译器不再重排关于这个类型的操作</p>\n<h2>Acquire and Release</h2>\n<p>an acquire access ensures that every access after it stays after it. However operations that occur before an acquire are free to be reordered to occur after it. Similarly, a release access ensures that every access before it stays before it. However operations that occur after a release are free to be reordered to occur before it.<br>\nAcquire 后方固化保证在Acquire之后的操作永远在Acquire之后<br>\nRelease 前方固化保证在Release之前的操作永远在Release之前</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rust line-numbers\"><code class=\"language-rust\"><span class=\"token keyword\">use</span> std<span class=\"token punctuation\">::</span>sync<span class=\"token punctuation\">::</span>Arc<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> std<span class=\"token punctuation\">::</span>sync<span class=\"token punctuation\">::</span>atomic<span class=\"token punctuation\">::</span><span class=\"token punctuation\">{</span>AtomicBool<span class=\"token punctuation\">,</span> Ordering<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> std<span class=\"token punctuation\">::</span>thread<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> lock <span class=\"token operator\">=</span> Arc<span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>AtomicBool<span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// value answers \"am I locked?\"</span>\n\n    <span class=\"token comment\">// ... distribute lock to threads somehow ...</span>\n\n    <span class=\"token comment\">// Try to acquire the lock by setting it to true</span>\n    <span class=\"token keyword\">while</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">compare_and_swap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">false</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">true</span><span class=\"token punctuation\">,</span> Ordering<span class=\"token punctuation\">::</span>Acquire<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// broke out of the loop, so we successfully acquired the lock!</span>\n\n    <span class=\"token comment\">// ... scary data accesses ...</span>\n\n    <span class=\"token comment\">// ok we're done, release the lock</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">store</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">false</span><span class=\"token punctuation\">,</span> Ordering<span class=\"token punctuation\">::</span>Release<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>Relaxed</h2>\n<p>Relaxed accesses are the absolute weakest. They can be freely re-ordered and provide no happens-before relationship. Still, relaxed operations are still atomic. That is, they don't count as data accesses and any read-modify-write operations done to them occur atomically. Relaxed operations are appropriate for things that you definitely want to happen, but don't particularly otherwise care about. For instance, incrementing a counter can be safely done by multiple threads using a relaxed fetch_add if you're not using the counter to synchronize any other accesses.</p>"}},"pageContext":{"slug":"/share/编程语言要素/rust/atomic/"}}}