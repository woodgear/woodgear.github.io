{"data":{"markdownRemark":{"html":"<h1>无类型lambda演算</h1>\n<p>给定以下三条规则</p>\n<ol>\n<li>a\t变量\t表示参数或数学/逻辑值的字符或字符串</li>\n<li>(λx.M)\t抽象化\t函数定义（M是一个lambda项）。变量x在表达式中已被绑定。</li>\n<li>(M N)\t应用\t将函数应用于参数。 M 和 N 是 lambda 项。</li>\n</ol>\n<h1>穷人的不动点</h1>\n<p>假设我我要写N的累加 1+2+3+...n\n(伪代码警告)\n<code class=\"language-text\">let f = lambda n. n==1?1:f(n-1)</code>\n但问题在于 lambda 定义部分中的f 在函数未定义时是不存在的.\n那么</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">let f = lambda self,n. n==1?1:n+self(n-1)\nf(f,n)</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>不过上述代码其实是有问题的 因为f要求有两个参数 而我们使用self时只传了n-1 这一个参数.\n所以实际上是</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">let f = lambda self,n. n==1?1:n+self(self,n-1)\nf(f,n)</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>这就是所谓的 >穷人的不动点</p>\n<h1>为什么有了Y组合子之后就能表达递归</h1>\n<p>Y组合子指的是某种magic使得 Y(g) = g(Y(g))\n可以通俗的理解为 存在某种操作(函数,实际上是高阶函数)Y,给Y一个g(函数), Y(g) 实际上能够产生出函数 g(Y(g)) 也就是讲 Y(g)等同于以Y(g)作为参数调用g</p>\n<p>这样的话 我们的穷人的不动点就可以升级为正常的不动点了</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// 公式1\nlet f = Y(lambda self,n. n==1?1:n+self(n-1))\nf 3</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>但为什么呢? <em>为什么有了Y组合子之后就能表达递归</em> 为了理解我们需要 手动展开 来演练一下\n首先是 g 在上述函数中 g 实际上指的是 <code class=\"language-text\">lambda self,n. n==1?1:self(n-1)</code>,总而言之 是一个有两个函数的参数, 并且在计算的过程中我们会一某种程度上减小了问题规则的参数来a调用<code class=\"language-text\">self</code>\n展开 </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">f 3 =&gt; Y(g)(3)          # Y(g) 会返回某个函数 我们以3为参数调用他\n      =&gt; g(Y(g))(3)     # Y(g) 实际上返回的函数是g(Y(g)) 已经被填充一个参数的双参函数 以3为参数去调用他 实际上是在以 Y(g)和3为参数在调用g\n      =&gt; 3+ Y(g)(2)     # 还记得g的定义 n==1?1+n+self(n-1) 此时这里的self 就是Y(g)\n      =&gt; 3 + g(Y(g))(2) # 这里已经可以看到递归的形成了  g(Y(g))(3) 变成了3 + g(Y(g))(2)\n      =&gt; 3 + 2 + Y(g)1\n      =&gt; 3 + 2 + g(Y(g))1\n      =&gt; 3 + 2 + 1      # 到达了g的终止条件 n==1</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1>Y组合子的特性</h1>\n<h1>ref</h1>\n<p><a href=\"https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97\"></a></p>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/share/y组合子/"}}