{"data":{"markdownRemark":{"html":"<!-- slide -->\n<h2>什么是可观测性</h2>\n<p><img src=\"/1e3ee8ec6ddea885250d135a326ba5d8/apple.jpg\" alt=\"苹果\"></p>\n<p>对于一个苹果，我们说他是可观测的，当我们看着这个平果的时候\n我们能够从中观察的到一些信息，例如</p>\n<ol>\n<li>颜色</li>\n<li>大小</li>\n<li>形状</li>\n<li>斑纹</li>\n</ol>\n<p>如果是有经验的果农能还能知道苹果的品种，甜度，口感.</p>\n<p>可观测性指的就是对于一个给定的物体，你能够通过各种手段进行观察，从而从中获取到更多的信息，从而加深对其的理解</p>\n<!-- slide -->\n<h2>Linux 可观测性</h2>\n<img src=\"/620e3a54f99a5cd2739a217f311ee7c8/bpf_performance_tools.png\" alt=\"drawing\" width=\"980\"/>\n<p>一个正在运行的操作系统,抽象的看大致由CPU 调度器/网络调度器/文件系统调度器三大部分组成，每个部分又通过各种系统调用为用户态程序提供接口。对于 linux 系统的观测，很大一部份就是对于这些模块的观测，问题在于，如何去观测？这次介绍的 EBPF 就为这种观测能力提供了手段</p>\n<!-- slide -->\n<h2>从BPF说起</h2>\n<p>需求： 网络包 过滤/监控</p>\n<h2>BPF工作流程</h2>\n<p><img src=\"/e9a44ba54927cb38418297f2abaca265/bpf%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png\">\n对于一个网络包 如果通过bpf过滤则保留,不满足则drop.</p>\n<h3>实现</h3>\n<ol>\n<li>内核虚拟机</li>\n<li>\n<p>JIT编译</p>\n<h2>BPF历史</h2>\n</li>\n<li>1992论文 <code class=\"language-text\">&lt;&lt;A New Architecture for User-level Packet Capture&gt;&gt;</code></li>\n<li>1997 linux 2.1.75 add bpf</li>\n<li>\n<p>2011 linux 3.0 jit</p>\n<aside class=\"notes\">\n</li>\n</ol>\n<p>讲到EBPF 这个E指的实际上是extend也就是加强版的意思,要了解整个EBPF的历史,就要从BPF开始讲起.<br>\n有一种需求是对流经整个系统的网络包做监控和过滤<br>\n在1992年有篇论文提出这种过滤/捕获网络包的方法.大致上就是如图所示,用户将过滤指令发到内核的一个虚拟机上,网络包通过虚拟机执行一遍，做出接受还是drop的判断从而过滤网络包,我们常用的tcpdump和wirehshark实际使用的就是这种方式。<br>\n在1997年linux 2.1.75的时候种bpf被merge Linux内核\n在2011年linux 3.0 发布,实现了一个BPF虚拟机的优化,JIT就是虽然我们有虚拟机这个概念,但虚拟机的指令集会被JIT优化成机器码进行执行.</p>\n</aside>\n<!-- slide -->\n## 工作模型\n![](./bpf工作流程.png)\n事件源(网络包)=>虚拟机=>(accept/drop)\n<aside class=\"notes\">\n如果我们回过头来看这个BPF的工作模型,大概是这个样子\n事件源现在也就是网络包经过虚拟机的判断,得出了一些结果,这里就是接受或者丢弃网络包\n</aside>\n<!-- slide -->\n## 事件源为什么一定是网络包?\n<img src=\"/620e3a54f99a5cd2739a217f311ee7c8/bpf_performance_tools.png\" alt=\"drawing\" width=\"980\"/>\n<aside class=\"notes\">\n但事件源为什么非得是网络包呢?仔细想想整个系统中有很多可以成为事件源的东西\n</aside>\n<!-- slide -->\n<h2>事件源(linux hook)</h2>\n<h3>KPROBE</h3>\n<p>linux内核空间系统调用,每一个内核态系统调用可以是一个事件源</p>\n<h3>UPROBE</h3>\n<p>linux用户空间(应用程序)调用,每一个用户态函数调用可以是一个事件源</p>\n<h3>trace-point</h3>\n<p>custom trace event,linux内核可以自定义事件</p>\n<h3>USDT</h3>\n<p>用户程序可以自定义事件</p>\n<h3>PMC 性能计数器(Performance monitoring counters)</h3>\n<p>CPU的性能采样计数器</p>\n<ol>\n<li>L1缓存成功/失败率</li>\n<li>\n<p>分支预测成功/失败率</p>\n<aside class=\"notes\">\n下面我会给大家简要介绍一下这几种事件源的原理\n</aside>\n</li>\n</ol>\n<!-- slide -->\n<h2>KPROBE/UPROBE 原理</h2>\n<p>动态的改变linux内核指令流,插入一个int3指令(x86)从而跳转到probe逻辑.\n<img src=\"/7437d6609ae3af291c6168611ff92f2b/uprobe-diagram.jpg\"></p>\n<ol>\n<li>通常来讲我们常见的hook点是函数入口和函数结束</li>\n<li>因为kprobe通常被设置在函数入口点,所有我们也可以通过寄存器获取到这个函数的参数(后边bash readline会演示)</li>\n</ol>\n<aside class=\"notes\">\nkprobe和uprobe实际上是Linux提供的一个动态指令的技术.他实际上提供的是对内核空间的任何指令加上pre和post handle的能力,\n具体的工作流程大概是\n1. 保存要插入hook的指令,并替换成一个断点指令(int3)\n2. 程序执行到这个指令时会进入到断点处理流程中,其实就是执行我们注入的pre_handle\n3. 执行完pre_handle后,设置CPU为单步执行模式,在这种模式下,执行完一个指令就会又陷入到中断处理中,同时将下一条指令设置为我们之前保留的原指令\n4. 重新进入中断,执行post_handle 修复寄存器和栈\n</aside>\n<!-- slide --> \n<h3>trace-point原理</h3>\n<p><img src=\"/5d410586867ac56c284ea1ac516968aa/tracepoint.png\"></p>\n<aside class=\"notes\">\ntrace point 也是内核提供的一个hook机制,不过不同于kprobe,这些hook的点时人手工埋进去的\n他大致的工作流程就是\n1. 调用函数注册hook到hook队列中\n2. 执行到相应trace-point 在事件处理的队列中一个执行\n</aside>\n<p>不同于kprobe  </p>\n<ol>\n<li>tracepoint是内核代码中硬编码的,采用的是自己的一套注册hook的机制</li>\n<li>tracepoint比较稳定</li>\n</ol>\n<!-- slide --> \n<h3>USDT原理</h3>\n<img src=\"/8de330a3736c30df0034a26827c5379b/linux-tracing-usdt.png\" alt=\"drawing\" height=\"980\"/>\n<aside class=\"notes\">\nUSDT的工作原理实际上可以说时结合kprobe和trace point的特点\n首先它是人手动在代码中的埋点,其次也使用probe的断点处理的方法\n1. 在代码中手动指定要加入的tracepoint\n2. 编译时这些trace point会被编译成noop空指令 并在ELF头中记录下这些指令的位置\n3. 如果真的要去追踪这些trace point uprobe会找到这些noop空指令将他们变成断点指令 然后就跟之前介绍的机制一样了\n</aside>\n<!-- slide --> \n## traceing system 历史\n<img src=\"/14048e58db6999e12a6446b328fc12cf/linux-tracing-timeline.png\" wight=\"1920\"/>\n<aside class=\"notes\">\n有几个比较重要的节点\n1. 2004年 linux kprobe被merge到内核\n2. 2014 ebpf补丁被merge到内核，就是这个补丁，将BPF变成了EBPF\n</aside>\n<!-- slide --> \n## 处理流程为什么一定是简单的匹配?\n![](./bpf工作流程.png)\n事件源(kprobe/uprobe/tracepoint/usdt)=>虚拟机=>(?)\n<!-- slide --> \n## 虚拟机对比\n![](./bpf-ebpf虚拟机对比.png)\n<!-- slide --> \n## EBPF 工作流程\n![](./ebpf工作流程.png)\n<aside class=\"notes\">\n这张图大概描述了EBPF的工作流程，用户的BPF程序被编译成BPF字节码，在内核中首先通过校验器的校验，这一步能够保证EBPF程序是安全的，不会break掉内核。然后在各种事件发生的时候调用\n</aside>\n<!-- slide --> \n<h2>EBPF 工作流程</h2>\n<p><img src=\"/c596e34e426b4679a12b63f677c4a241/enpf%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E8%AF%A6%E7%BB%86.png\"></p>\n<aside class=\"notes\">\n这个是更详细一点的内核态的EBPF工作流程，如果开启了JIT的话BPF虚拟机指令会再被编译成机器码执行\n</aside>\n<!-- slide --> \n## BCC/BPFtrace lib\n![](./bcc-bpftrace.png)\n1. LLVM\n2. bcc\n3. BPFtrace\n<aside class=\"notes\">\nLLVM现在也支持BPF做为后端，所以理论上我们可以用任何支持LLVM的语言来写BPF\n</aside>\n<!-- slide --> \n## BPFTRACE a lang for trace\n```bpftrace\n#!/usr/local/bin/bpftrace\n// this program times vfs_read()\nkprobe:vfs_read\n{ \n        @start[tid] = nsecs;\n}\n<p>kretprobe:vfs<em>read\n/@start[tid]/\n{<br>\n$duration</em>us = (nsecs - @start[tid]) / 1000;\n@us = hist($duration_us);\ndelete(@start[tid]);\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">但作为日常的使用，实际上我们还可以使用一种bpf特有的脚本语言\n基本有三部分组成\n1. hook\n2. 对map的访问/基本条件控制语法\n3. bpf帮助函数\n\n&lt;!-- slide --&gt; \n## EBPF限制\n1. 循环次数\n2. 堆栈大小限制\n3. 指令数限制\n&lt;!-- slide --&gt;\n\n## EBPF其他用处\n* SDN 软件定义网络  Cilium 基于EBPF实现的kube-proxy\n\n&lt;!-- slide --&gt;\n## lab\n### bcc tools\n1. execsnoop\n2. biolatency\n### bpftrace kernel mode\n1. 列出所有可以被设置trace的函数\n```bash\nsudo bpftrace -l &#39;*kprobe*&#39;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ol start=\"2\">\n<li>\n<p>跟踪udp协议 显示域名</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> gethostlatency</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h3>bpftrace uprobe bash readline</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">sudo bpftrace -e &#39;ur:/bin/bash:readline { printf(&quot;%s\\n&quot;, str(retval)); }&#39;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n</ol>","fields":{"slug":"/tech-share/ebpf.md/ebpf/","disqus":{"shortname":"woodgear-blog"}},"frontmatter":{"id":"5b0fd8","time":"2020-12-18T13:35:12+08:00","tag":null},"parent":{"__typename":"File","name":"ebpf","ext":".md","birthTime":"1970-01-01T00:00:00.000Z","changeTime":"2020-12-18T05:37:36.847Z","relativeDirectory":"tech-share/ebpf.md","absolutePath":"/home/oaa/ns/share/blog/tech-share/ebpf.md/ebpf.md"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/tech-share/ebpf.md/ebpf/","disqus":{"shortname":"woodgear-blog"}}}