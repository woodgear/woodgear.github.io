{"data":{"markdownRemark":{"html":"<p><a href=\"https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(object-oriented_programming\">https://en.wikipedia.org/wiki/Comparison<em>of</em>programming<em>languages</em>(object-oriented_programming</a>)</p>\n<h1>l-dpendency</h1>\n<p>如何使用他人的库</p>\n<ol>\n<li>原理是什么</li>\n<li>如何增加/安装/使用一个库</li>\n<li>\n<p>国内镜像(233)</p>\n<h2>tips</h2>\n</li>\n<li>远程模型/本地模块?</li>\n<li>\n<p>在局部作用域中暴露命名空间 (在一个函数内,引入某个模块的所有命名空间)</p>\n<h1>doc</h1>\n<p>如何生成文档?如何在代码中书写文档</p>\n</li>\n</ol>\n<h1>l-io</h1>\n<h2>l-console-out</h2>\n<p>向控制台输出的能力</p>\n<h1>interface</h1>\n<p>interface 对类或者对数据结构作出描述,而我们根据这种事先的约定/约束 操作数据,而不用关心具体的实现\n据此,在真正的编程语言中我们要关注的是 </p>\n<ol>\n<li>如何定义interface </li>\n<li>如何实现interface</li>\n<li>\n<p>go [v]</p>\n<h2>tips</h2>\n</li>\n<li>\n<p>self?</p>\n<h2>advance-interface</h2>\n</li>\n</ol>\n<h1>函数定义 (l-function)</h1>\n<p>无论如何我们都需要某种机制让我们能够将逻辑/表达式 组合成一个上层的有语义的逻辑块,函数是第一层的封装.函数要素 1. 函数定义符 2. 函数名 3. 参数 4. 返回值</p>\n<ul>\n<li>\n<p>go [v]</p>\n<h2>函数参数定义 (l-function-args)</h2>\n<p>有些语言允许同时定义多个元素的类型</p>\n</li>\n<li>go [v]</li>\n<li>\n<p>rust [x]</p>\n<h2>tips (l-anonymous-function)</h2>\n<p>此外还有如何定义匿名函数,即闭包</p>\n</li>\n</ul>\n<h1>结构体定义 (l-struct)</h1>\n<p>无论如何我们需要某种机制让我们能够将数据/类型 组合成一个有上层语义的数据/类型</p>\n<h2>构造结构体 (l-construct-struct)</h2>\n<h1>l-statement</h1>\n<h2>l-select</h2>\n<p>根据条件判断执行某些语句.<br>\n条件判断可以是简单的bool,也可能是模式匹配.<br>\n执行语句可能是简单的执行一次,也可能是执行完成后再循环</p>\n<h3>l-if/else</h3>\n<h3>l-loop</h3>\n<ul>\n<li>\n<p>go [v]</p>\n<h3>iterator (与loop不同iterator更加强调遍历容器)</h3>\n</li>\n</ul>\n<h1>l-common-container</h1>\n<h1>l-string</h1>\n<h2>l-string-fmt</h2>\n<h2>l-string-api</h2>\n<ul>\n<li>\n<p>compare-string-dict-order</p>\n<h2>array</h2>\n<h3>l-array-range-access-syntax</h3>\n</li>\n</ul>\n<h2>quque</h2>\n<h2>map</h2>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/share/编程语言须知/语言要素/"}}