{"data":{"markdownRemark":{"html":"<p>-</p>\n<h1>使用AES加密解密</h1>\n<p>AES 是共享密钥加密 属于分组密码只能加密固定长度的明文(基于XOR) 那么一般以128bit为一组 进行迭代加密 128bit=>16字节=>16个ascii字符\n因此使用AES加密时一般需要16个ascii作为密钥\n<a href=\"https://www.devglan.com/online-tools/aes-encryption-decryption\">online</a></p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-sh line-numbers\"><code class=\"language-sh\">// 加密 base64 输出\necho hello,world! |openssl enc -aes-256-ecb  -nosalt  -base64 --pass pass:8579831002000329\n// 解密\necho 4wA5xW0TVkRQd9ZtVxgmNQ== |openssl enc -d -aes-256-ecb  -nosalt  -base64 --pass pass:8579831002000329</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<h1>生成公钥私钥</h1>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-sh line-numbers\"><code class=\"language-sh\">// 生成私钥\nopenssl genrsa -aes128 -passout pass:demo -out private.pem 4096\n// 根据私钥生成公钥\nopenssl rsa -in private.pem -passin pass:demo -pubout -out public.pem</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<h1>使用公钥加密文件</h1>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-sh line-numbers\"><code class=\"language-sh\">echo hello,world! &gt; test_ras.txt\nopenssl rsautl -encrypt -inkey public.pem -pubin -in test_rsa.txt -out test_rsa.enc\nbase64 test_rsa.enc</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h1>使用私钥解密文件</h1>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-sh line-numbers\"><code class=\"language-sh\">openssl rsautl -decrypt -inkey private.pem -in test_rsa.enc -out test_rsa.decrtpt</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h1>使用私钥签名文件</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">openssl dgst -sha256 -sign private.pem -out ./test_rsa.txt.sign.sha256 ./test_rsa.txt</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h1>使用公钥验证签名文件</h1>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-sh line-numbers\"><code class=\"language-sh\">openssl dgst -sha256 -verify public.pem -signature ./test_rsa.txt.sign.sha256 ./test_rsa.txt</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h1>证书</h1>\n<p>证书中存储了一个上级CA的签名 一个被公正的公钥</p>\n<h1>使用生成的公钥注册证书</h1>\n<p>注册证书看起来要依赖他人的服务 因此这是使用自签名的证书</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-sh line-numbers\"><code class=\"language-sh\">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h1>验证证书(确认证书中的公钥经过CA的公正)</h1>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-sh line-numbers\"><code class=\"language-sh\">// 从证书中获取公钥\nopenssl x509 -pubkey -noout -in cert.pem  &gt; pubkey.pem\n// 从证书中获取签名\n// 获取签名的公钥(拿到此证书的签名的公钥 这一步会递归到根证书)\n// 验证签名\n// 使用签名验证公钥</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1>自签名证书作为根证书 生成子证书</h1>\n<h1>尝试使用自己的私钥解密https</h1>\n<h1>windows side</h1>\n<h2>pfx</h2>\n<p>windows pfx格式的证书只要双击文件就行了,会弹出窗口一直无脑点下一步即可</p>\n<h2>tips</h2>\n<p>证书过期删除旧的驱动直接用certmgr找到然后删除即可,有的时候找不到旧的证书 可以在IE->Internet 选项->内容->证书中找找</p>\n<h1>refs</h1>\n<p><a href=\"https://www.zimuel.it/blog/sign-and-verify-a-file-using-openssl\">sign-and-verify-a-file-using-openssl)</a></p>","fields":{"slug":"/share/证书签名/","disqus":{"shortname":"woodgear-blog"}},"frontmatter":{"id":"aq05ugj","time":"1996-09-08T23:37:07+08:00","tag":"密码 RAS 公钥私钥 证书 签名 https 加密解密"},"parent":{"__typename":"File","name":"证书签名","ext":".md","birthTime":"2020-08-12T15:37:07.087Z","changeTime":"2020-08-12T17:06:56.339Z","relativeDirectory":"share","absolutePath":"/home/oaa/temp/blog/share/证书签名.md"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/share/证书签名/","disqus":{"shortname":"woodgear-blog"}}}