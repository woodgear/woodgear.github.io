{"data":{"markdownRemark":{"html":"<h1>Cell</h1>\n<h2>Cell是什么东西</h2>\n<pre><code class=\"language-rust\">#[repr(transparent)]\npub struct Cell&#x3C;T: ?Sized> {\n    value: UnsafeCell&#x3C;T>,\n}\nimpl&#x3C;T> Cell&#x3C;T> {\n    pub const fn new(value: T) -> Cell&#x3C;T> {\n        Cell {\n            value: UnsafeCell::new(value),\n        }\n    }\n    pub fn set(&#x26;self, val: T) {\n        let old = self.replace(val);\n        drop(old);\n    }\n}\n</code></pre>\n<p>Cell的set方法只要求拥有不可变的reference 这就是她最大的作用</p>\n<h2>有什么用 或者说在实际的例子中人们是怎么使用Cell的</h2>\n<h3>假设我们希望不用mut ref 一个struct 来mut一个struct (hahahah)</h3>\n<pre><code class=\"language-rust\">use std::cell::Cell;\n\nstruct SomeStruct {\n    regular_field: u8,\n    special_field: Cell&#x3C;u8>,\n}\n\nlet my_struct = SomeStruct {\n    regular_field: 0,\n    special_field: Cell::new(1),\n};\n\nlet new_value = 100;\n\n// ERROR, because my_struct is immutable\n// my_struct.regular_field = new_value;\n\n// WORKS, although `my_struct` is immutable, field `special_field` is mutable because it is Cell\nmy_struct.special_field.set(new_value);\nassert_eq!(my_struct.special_field.get(), new_value);\n</code></pre>\n<h3>希望做一些兼容性的操作</h3>\n<p>or because you must employ mutation to implement a trait method that was originally defined to take &#x26;self.</p>\n<h3>偷偷的进行mut 理论上不用mut的地方在实现上需要mut</h3>\n<ol>\n<li>\n<p>例如实现memorize 每次只是get(&#x26;self) 但实际上要修改缓存(&#x26;mut self)</p>\n<pre><code class=\"language-rust\">use std::cell::RefCell;\n</code></pre>\n</li>\n</ol>\n<p>struct Graph {\nedges: Vec&#x3C;(i32, i32)>,\nspan<em>tree</em>cache: RefCell&#x3C;Option&#x3C;Vec&#x3C;(i32, i32)>>>\n}</p>\n<p>impl Graph {\nfn minimum<em>spanning</em>tree(&#x26;self) -> Vec&#x3C;(i32, i32)> {\n// Create a new scope to contain the lifetime of the\n// dynamic borrow\n{\n// Take a reference to the inside of cache cell\nlet mut cache = self.span<em>tree</em>cache.borrow<em>mut();\nif cache.is</em>some() {\nreturn cache.as_ref().unwrap().clone();\n}</p>\n<pre><code>        let span_tree = self.calc_span_tree();\n        *cache = Some(span_tree);\n    }\n\n    // Recursive call to return the just-cached value.\n    // Note that if we had not let the previous borrow\n    // of the cache fall out of scope then the subsequent\n    // recursive borrow would cause a dynamic thread panic.\n    // This is the major hazard of using `RefCell`.\n    self.minimum_spanning_tree()\n}\n</code></pre>\n<p>}</p>\n<pre><code>2. 例如引用计数在clone(&#x26;self)时要增加count(&#x26;mut self)\n```rust\n#![feature(core_intrinsics)]\nuse std::cell::Cell;\nuse std::ptr::NonNull;\nuse std::intrinsics::abort;\n\nstruct Rc&#x3C;T: ?Sized> {\n    ptr: NonNull&#x3C;RcBox&#x3C;T>>\n}\n\nstruct RcBox&#x3C;T: ?Sized> {\n    strong: Cell&#x3C;usize>,\n    refcount: Cell&#x3C;usize>,\n    value: T,\n}\n\nimpl&#x3C;T: ?Sized> Clone for Rc&#x3C;T> {\n    fn clone(&#x26;self) -> Rc&#x3C;T> {\n        self.inc_strong();\n        Rc { ptr: self.ptr }\n    }\n}\n\ntrait RcBoxPtr&#x3C;T: ?Sized> {\n\n    fn inner(&#x26;self) -> &#x26;RcBox&#x3C;T>;\n\n    fn strong(&#x26;self) -> usize {\n        self.inner().strong.get()\n    }\n\n    fn inc_strong(&#x26;self) {\n        self.inner()\n            .strong\n            .set(self.strong()\n                     .checked_add(1)\n                     .unwrap_or_else(|| unsafe { abort() }));\n    }\n}\n\nimpl&#x3C;T: ?Sized> RcBoxPtr&#x3C;T> for Rc&#x3C;T> {\n   fn inner(&#x26;self) -> &#x26;RcBox&#x3C;T> {\n       unsafe {\n           self.ptr.as_ref()\n       }\n   }\n}\n</code></pre>\n<h3>当我们有某个共有的变量 同时有多个struct希望能够修改她</h3>\n<pre><code class=\"language-rust\">struct A&#x3C;'a>(&#x26;'a mut i32);\n\nimpl&#x3C;'a> A&#x3C;'a> {\n    fn change_to(&#x26;mut self, v: i32) {\n        *self.0 = v;\n    }\n}\n\nfn main() {\n    let mut x = 10;\n    let mut a = A(&#x26;mut x);\n    let mut b = A(&#x26;mut x);\n    a.change_to(2);\n    // b.change_to(1);\n    println!(\"{:?}\",x);\n}\n\n// use std::cell::Cell;\n\n// struct A&#x3C;'a>(&#x26;'a Cell::&#x3C;i32>);\n\n// impl&#x3C;'a> A&#x3C;'a> {\n//     fn change_to(&#x26;self,v:i32){\n//         self.0.set(v);\n//     }\n// }\n\n// fn main() {\n//     let x = Cell::new(10);\n//     let a = A(&#x26;x);\n//     let b = A(&#x26;x);\n//     b.change_to(1);\n//     a.change_to(2);\n//     println!(\"{:?}\",x);\n// }\n</code></pre>\n<h1>RefCell</h1>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/I Want To Talk/rust/wrap_type/","fileNode":"fileNode"}}