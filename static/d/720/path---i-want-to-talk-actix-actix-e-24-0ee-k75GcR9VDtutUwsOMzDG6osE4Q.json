{"data":{"markdownRemark":{"html":"<h1>为什么能够通过addres 来send msg</h1>\n<p>contextimpl 中的poll中执行力self.mailbox.poll(self,act) 其中一直在读msg然后执行msg的handle方法 实际上就接收到了Msg\n每个addres 通过Arc共享一份内存一直在push msg</p>\n<h1>AddressSenderProducter的Send方法在做什么?</h1>\n<p>递增num_senders并构造AddressSender\n只不过多线程问题 所以用了原子类型操作而已</p>\n<h1>task current 在做什么</h1>\n<p>目前acti使用的时future 1.0 + tokio 1.x 并没有搞懂里面具体的逻辑 不过大意就是获得了一个当前线程的waker 以便在后面通过notify通知到对应的actor 可以参照 <a href=\"../aync_book\">rust async book</a>中的例子就懂了</p>\n<h1>当Actor启动时发生了什么</h1>\n<p>如actix.pdf</p>\n<h1>当我们在Handle Msg 时通过ctx 自己给自己notify 一个msg时 我们做了什么</h1>\n<p>类似于此的函数实质就是直接调用spawn</p>\n<pre><code class=\"language-rust\">    /// Sends the message `msg` to self.\n    fn notify&#x3C;M>(&#x26;mut self, msg: M)\n    where\n        A: Handler&#x3C;M>,\n        M: Message + 'static,\n    {\n        if self.state() == ActorState::Stopped {\n            error!(\"Context::notify called for stopped actor.\");\n        } else {\n            self.spawn(ActorMessageItem::new(msg));\n        }\n    }\n\n    fn notify_later&#x3C;M>(&#x26;mut self, msg: M, after: Duration) -> SpawnHandle\n    where\n        A: Handler&#x3C;M>,\n        M: Message + 'static,\n    {\n        if self.state() == ActorState::Stopped {\n            error!(\"Context::notify_later called for stopped actor.\");\n            SpawnHandle::default()\n        } else {\n            self.spawn(ActorDelayedMessageItem::new(msg, after))\n        }\n    }\n\n    fn run_later&#x3C;F>(&#x26;mut self, dur: Duration, f: F) -> SpawnHandle\n    where\n        F: FnOnce(&#x26;mut A, &#x26;mut A::Context) + 'static,\n    {\n        self.spawn(TimerFunc::new(dur, f))\n    }\n\n    /// Spawns a job to execute the given closure periodically, at a\n    /// specified fixed interval.\n    fn run_interval&#x3C;F>(&#x26;mut self, dur: Duration, f: F) -> SpawnHandle\n    where\n        F: FnMut(&#x26;mut A, &#x26;mut A::Context) + 'static,\n    {\n        self.spawn(IntervalFunc::new(dur, f).finish())\n    }\n}\n</code></pre>\n<p>至于spawn 本身则是将这个这个future丢到了contextimpl的items中可以参见ContextFut的poll 这里又去poll了self.items实际上就是执行了一下这些fututre</p>\n<pre><code class=\"language-rust\">    #[inline]\n    /// Spawn new future to this context.\n    pub fn spawn&#x3C;F>(&#x26;mut self, fut: F) -> SpawnHandle\n    where\n        F: ActorFuture&#x3C;Item = (), Error = (), Actor = A> + 'static,\n    {\n        let handle = self.handles[0].next();\n        self.handles[0] = handle;\n        let fut: Box&#x3C;ActorFuture&#x3C;Item = (), Error = (), Actor = A>> = Box::new(fut);\n        self.items.push((handle, fut));\n        handle\n    }\n</code></pre>\n<h1>当我们获得一个actor的address 并通过这个address send一个msg时 我们做了什么</h1>\n<p>每一个Actor的address实际上共享一个队列 send msg 时实际上就是将msg丢到Actor的message_queue中并且去notify这个Actor</p>\n<pre><code class=\"language-rust\">pub struct AddressSender&#x3C;A: Actor> {\n    inner: Arc&#x3C;Inner&#x3C;A>>,\n    // 省略\n}\nimpl&#x3C;A: Actor> AddressSender&#x3C;A> {\n    pub fn send&#x3C;M>(&#x26;self, msg: M) -> Result&#x3C;Receiver&#x3C;M::Result>, SendError&#x3C;M>>\n    where\n        A: Handler&#x3C;M>,\n        A::Context: ToEnvelope&#x3C;A, M>,\n        M::Result: Send,\n        M: Message + Send,\n    {\n        if !self.poll_unparked(false).is_ready() {\n            return Err(SendError::Full(msg));\n        }\n        let park_self = match self.inc_num_messages() {\n            Some(park_self) => park_self,\n            None => return Err(SendError::Closed(msg)),\n        };\n\n        if park_self {\n            self.park(true);\n        }\n        let (tx, rx) = sync_channel();\n        let env = &#x3C;A::Context as ToEnvelope&#x3C;A, M>>::pack(msg, Some(tx));\n        self.queue_push_and_signal(env);\n        Ok(rx)\n    }\n    fn queue_push_and_signal(&#x26;self, msg: Envelope&#x3C;A>) {\n        self.inner.message_queue.push(msg);\n        self.signal();\n    }\n    \n    fn signal(&#x26;self) {\n        let task = {\n            let mut recv_task = self.inner.recv_task.lock();\n            if recv_task.unparked {\n                return;\n            }\n\n            recv_task.unparked = true;\n            recv_task.task.take()\n        };\n\n        if let Some(task) = task {\n            task.notify();\n        }\n    }\n}\n</code></pre>\n<p>剩下的问题就是address是怎么来的</p>\n<ol>\n<li>Actor启动时返回的Address</li>\n</ol>\n<pre><code class=\"language-rust\">impl&#x3C;A> Context&#x3C;A>\nwhere\n    A: Actor&#x3C;Context = Self>,\n{\n    #[inline]\n    pub(crate) fn new() -> Context&#x3C;A> {\n        let mb = Mailbox::default();\n        Context {\n            parts: ContextParts::new(mb.sender_producer()),\n            mb: Some(mb),\n        }\n    }\n    #[inline]\n    pub fn run(self, act: A) -> Addr&#x3C;A> {\n        let fut = self.into_future(act);\n        let addr = fut.address();\n        Arbiter::spawn(fut);\n        addr\n    }\n\n}\nimpl&#x3C;A, C> ContextFut&#x3C;A, C>\nwhere\n    C: AsyncContextParts&#x3C;A>,\n    A: Actor&#x3C;Context = C>,\n{\n        #[inline]\n    pub fn address(&#x26;self) -> Addr&#x3C;A> {\n        self.mailbox.address()\n    }\n}\nimpl&#x3C;A> Mailbox&#x3C;A>\nwhere\n    A: Actor,\n    A::Context: AsyncContext&#x3C;A>,\n{\n    pub fn address(&#x26;self) -> Addr&#x3C;A> {\n        Addr::new(self.msgs.sender())\n    }\n}\n</code></pre>\n<p>问题就是MailBox的msgs到底是什么</p>\n<pre><code class=\"language-rust\">impl&#x3C;A> Default for Mailbox&#x3C;A>\nwhere\n    A: Actor,\n    A::Context: AsyncContext&#x3C;A>,\n{\n    #[inline]\n    fn default() -> Self {\n        let (_, rx) = channel::channel(DEFAULT_CAPACITY);\n        Mailbox { msgs: rx }\n    }\n}\n</code></pre>\n<p>channel又是一个很麻烦的东西</p>\n<pre><code class=\"language-rust\">pub fn channel&#x3C;A: Actor>(buffer: usize) -> (AddressSender&#x3C;A>, AddressReceiver&#x3C;A>) {\n    // Check that the requested buffer size does not exceed the maximum buffer\n    // size permitted by the system.\n    assert!(buffer &#x3C; MAX_BUFFER, \"requested buffer size too large\");\n\n    let inner = Arc::new(Inner {\n        buffer: AtomicUsize::new(buffer),\n        state: AtomicUsize::new(INIT_STATE),\n        message_queue: Queue::new(),\n        parked_queue: Queue::new(),\n        num_senders: AtomicUsize::new(1),\n        recv_task: Mutex::new(ReceiverTask {\n            unparked: false,\n            task: None,\n        }),\n    });\n\n    let tx = AddressSender {\n        inner: Arc::clone(&#x26;inner),\n        sender_task: Arc::new(Mutex::new(SenderTask::new())),\n        maybe_parked: Arc::new(AtomicBool::new(false)),\n    };\n\n    let rx = AddressReceiver { inner };\n\n    (tx, rx)\n}\n</code></pre>\n<p>在这里我们可以看到Inner终于被创建出来的 下面的无论是sender 还是sender_producer 实质上使用的都是同一份inner 也就是说通过Actor的address() 就能够将Msg丢到Actor的MailBox中这样在Actor被poll时他就会通过self.mailbox.poll()来调用真正的处理函数</p>\n<pre><code class=\"language-rust\">impl&#x3C;A: Actor> AddressReceiver&#x3C;A> {\n    pub fn sender(&#x26;self) -> AddressSender&#x3C;A> {\n        // this code same as Sender::clone\n        let mut curr = self.inner.num_senders.load(SeqCst);\n\n        loop {\n            // If the maximum number of senders has been reached, then fail\n            if curr == self.inner.max_senders() {\n                panic!(\"cannot clone `Sender` -- too many outstanding senders\");\n            }\n\n            let next = curr + 1;\n            let actual = self.inner.num_senders.compare_and_swap(curr, next, SeqCst);\n\n            // The ABA problem doesn't matter here. We only care that the\n            // number of senders never exceeds the maximum.\n            if actual == curr {\n                return AddressSender {\n                    inner: Arc::clone(&#x26;self.inner),\n                    sender_task: Arc::new(Mutex::new(SenderTask::new())),\n                    maybe_parked: Arc::new(AtomicBool::new(false)),\n                };\n            }\n\n            curr = actual;\n        }\n    }\n\n    /// Creates the sender producer.\n    pub fn sender_producer(&#x26;self) -> AddressSenderProducer&#x3C;A> {\n        AddressSenderProducer {\n            inner: self.inner.clone(),\n        }\n    }\n}\n## ReceiverTask 中的task什么时候被设置进去的\n初始化时为none在AddressReceiver被poll时 (mailbox被poll时) 的try_park中被设置\n也就是在Actor第一次被Poll时设置 也就是Arbiter::spawn时被设置\n```rust\nimpl&#x3C;A: Actor> Stream for AddressReceiver&#x3C;A> {\n    type Item = Envelope&#x3C;A>;\n    type Error = ();\n\n    fn poll(&#x26;mut self) -> Poll&#x3C;Option&#x3C;Self::Item>, Self::Error> {\n        loop {\n            // Try to read a message off of the message queue.\n            let msg = match self.next_message() {\n                Async::Ready(msg) => msg,\n                Async::NotReady => {\n                    // There are no messages to read, in this case, attempt to\n                    // park. The act of parking will verify that the channel is\n                    // still empty after the park operation has completed.\n                    match self.try_park() {\n                        TryPark::Parked => {\n                            // The task was parked, and the channel is still\n                            // empty, return NotReady.\n                            return Ok(Async::NotReady);\n                        }\n                        TryPark::NotEmpty => {\n                            // A message has been sent while attempting to\n                            // park. Loop again, the next iteration is\n                            // guaranteed to get the message.\n                            continue;\n                        }\n                    }\n                }\n            };\n\n            // If there are any parked task handles in the parked queue, pop\n            // one and unpark it.\n            self.unpark_one();\n\n            // Decrement number of messages\n            self.dec_num_messages();\n\n            // Return the message\n            return Ok(Async::Ready(msg));\n        }\n    }\n}\nimpl&#x3C;A: Actor> AddressReceiver&#x3C;A> {\n    fn try_park(&#x26;self) -> TryPark {\n        // First, track the task in the `recv_task` slot\n        let mut recv_task = self.inner.recv_task.lock();\n\n        if recv_task.unparked {\n            // Consume the `unpark` signal without actually parking\n            recv_task.unparked = false;\n            return TryPark::NotEmpty;\n        }\n\n        recv_task.task = Some(task::current());\n        TryPark::Parked\n    }\n}\n</code></pre>\n<p>至此一切就已经联系起来了\n当我们向adr中send msg 时实际上在向这个Actor的mailbox中的message_queue中推Envelope </p>\n<p>并且notify下Actor的Task因为Actor的第一次被poll就会设置task所以send了一个msg时能够找到Actor的task并去notify他</p>\n<h1>为什么Actor启动必须要System?</h1>\n<h1>Service 是如何工作的</h1>\n<h1>如何将Actor启动在不同的线程中</h1>\n<h1>当某个Actor阻塞时 之前在其中设置的Timer会有什么样的表现行为 为什么</h1>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/I Want To Talk/actix/actix/","fileNode":"fileNode"}}