{"data":{"markdownRemark":{"html":"<p>所以实际上讲重新poll一次future实际上是重新clone一个task丢到task的调用队列中再调用一次?\n所以讲实际上根本不存在调用 所有的future poll完一遍又会被重新丢到队列中直到下次被poll?那这样的话不就相当于死循环吗?\n不是的 例如例子上的TimeFuture实际上是TimeFuture自己调用的wake</p>\n<pre><code class=\"language-rust\">impl TimerFuture {\n    /// Create a new `TimerFuture` which will complete after the provided\n    /// timeout.\n    pub fn new(duration: Duration) -> Self {\n        let shared_state = Arc::new(Mutex::new(SharedState {\n            completed: false,\n            waker: None,\n        }));\n\n        dbg!(\"TimerFuture new\");\n        // Spawn the new thread\n        let thread_shared_state = shared_state.clone();\n        thread::spawn(move || {\n            dbg!(\"TimerFuture start thread\");\n            thread::sleep(duration);\n            dbg!(\"TimerFuture time consumed\");\n\n            let mut shared_state = thread_shared_state.lock().unwrap();\n            // Signal that the timer has completed and wake up the last\n            // task on which the future was polled, if one exists.\n            shared_state.completed = true;\n            if let Some(waker) = &#x26;shared_state.waker {\n                dbg!(\"TimeFuture state completed wakeup task\");\n                waker.wake();\n            }\n        });\n\n        TimerFuture { shared_state }\n    }\n}\nimpl Wake for Task {\n    fn wake(arc_self: &#x26;Arc&#x3C;Self>) {\n        // Implement `wake` by sending this task back onto the task channel\n        // so that it will be polled again by the executor.\n        let cloned = arc_self.clone();\n        arc_self.task_sender.send(cloned).expect(\"too many tasks queued\");\n    }\n}\n\nimpl Executor {\n    fn run(&#x26;self) {\n        dbg!(\"execute start to run\");\n        while let Ok(task) = self.ready_queue.recv() {\n            dbg!(\"get a task\");\n\n            let mut future_slot = task.future.lock().unwrap();\n            // Take the future, and if it has not yet completed (is still Some),\n            // poll it in an attempt to complete it.\n            if let Some(mut future) = future_slot.take() {\n                // Create a `LocalWaker` from the task itself\n                let lw = local_waker_from_nonlocal(task.clone());\n                if let Poll::Pending = Pin::new(&#x26;mut future).poll(&#x26;lw) {\n                    dbg!(\"excuttor try to poll and task is pending restore the task\");\n\n                    // We're not done processing the future, so put it\n                    // back in its task to be run again in the future.\n                    *future_slot = Some(future);\n                }\n            }\n        }\n    }\n}\n</code></pre>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/I Want To Talk/rust/async_book/"}}