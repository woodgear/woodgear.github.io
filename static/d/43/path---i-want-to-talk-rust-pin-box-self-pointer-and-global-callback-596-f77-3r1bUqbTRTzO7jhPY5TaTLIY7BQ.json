{"data":{"markdownRemark":{"html":"<pre><code class=\"language-rust\">#[derive(Debug)]\nstruct A {\n    data: String,\n}\nimpl A {\n    fn show(&#x26;mut self) -> u64 {\n        let p = self as *mut Self as u64;\n        println!(\"in start p is {:x} {:?}\", p, self);\n        p\n    }\n}\nstatic mut GLOBAL: Option&#x3C;A> = None;\n\nfn init() -> u64 {\n    let p: u64 = {\n        let mut a = A {\n            data: \"test\".to_string(),\n        };\n        let p = a.show();\n        unsafe { GLOBAL = Some(a) };\n        p\n    };\n    p\n}\n\npub fn main() {\n    let a_pointer = init();\n    unsafe { GLOBAL.as_mut().unwrap().show() };\n    let a_ref: &#x26;mut A = unsafe { &#x26;mut *(a_pointer as *mut A) };\n    a_ref.show();\n}\n</code></pre>\n<p>这段代码会崩溃 因为 在init中我们将A构造出来了所得到的A的指针p在init函数后指向的就是非法的内存了. 在init 之后 A被存储在GLOBAL中其地址与被初始化时不同\n解决的方法就是用Box</p>\n<pre><code class=\"language-rust\">#[derive(Debug)]\nstruct A {\n    data: String,\n}\n\nimpl A {\n    fn show(&#x26;mut self) -> u64 {\n        let p = self as *mut Self as u64;\n        println!(\"in start p is {:x} {:?}\", p, self);\n        p\n    }\n}\nstatic mut GLOBAL: Option&#x3C;Box&#x3C;A>> = None;\n\nfn init() -> u64 {\n    let p: u64 = {\n        let mut a = Box::new(A {\n            data: \"test\".to_string(),\n        });\n        let p = a.show();\n        unsafe { GLOBAL = Some(a) };\n        p\n    };\n    p\n}\n\npub fn main() {\n    let a_pointer = init();\n    unsafe { GLOBAL.as_mut().unwrap().show() };\n    let a_ref: &#x26;mut A = unsafe { &#x26;mut *(a_pointer as *mut A) };\n    a_ref.show();\n}\n</code></pre>\n<p>实际上这样的代码就可以正常编译运行了 但是还有一个问题那就是show方法的定义 问题的本质在于我们希望在调用show方法时拿到的self是不变的 即A的内存地址在调用show之后就不能发生变化 那么就是Pin</p>\n<pre><code class=\"language-rust\">#![feature(arbitrary_self_types)]\nuse core::pin::Pin;\n\n#[derive(Debug)]\nstruct A {\n    data: String,\n}\n\nimpl A {\n    fn show(self: Pin&#x3C;&#x26;mut Self>) -> u64 {\n        println!(\"in show self is {:?}\", self);\n        let p = self.get_mut() as *mut Self;\n        println!(\"in start pointer is {:?}\", p);\n        p as u64\n    }\n}\n\nstatic mut GLOBAL: Option&#x3C;Pin&#x3C;Box&#x3C;A>>> = None;\n\nfn init() -> u64 {\n    let p: u64 = {\n        let mut a = Pin::new(Box::new(A {\n            data: \"test\".to_string(),\n        }));\n        let p = a.as_mut().show();\n        unsafe { GLOBAL = Some(a) };\n        p\n    };\n    p\n}\n\npub fn main() {\n    let a = init();\n    let a= unsafe {&#x26;mut *(a as *mut A)};\n    a.show();\n    println!(\"a is {:?}\",a);\n}\n</code></pre>\n<p>这样好处就是我们无法在一个内存地址可能会发生变化的A上调用show 编译器会确保这一点</p>","frontmatter":{"title":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/I Want To Talk/rust/pin_box_self_pointer_and_global_callback/"}}