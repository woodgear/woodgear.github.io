{"data":{"markdownRemark":{"html":"<p>实现一个函数\n输入 命令行\n输出 此命令行的执行结果</p>\n<h1>c++</h1>\n<pre><code class=\"language-cpp\">#include \"stdafx.h\"\n#include &#x3C;Windows.h>\n#include &#x3C;string>\n#include &#x3C;iostream>\n#include &#x3C;sstream>\n#define BUFSIZE 4096\nusing namespace std;\n\nstd::string GetLastErrorAsString()\n{\n    //Get the error message, if any.\n    DWORD errorMessageID = ::GetLastError();\n    if (errorMessageID == 0)\n        return std::string(); //No error message has been recorded\n\n    LPSTR messageBuffer = nullptr;\n    size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&#x26;messageBuffer, 0, NULL);\n\n    std::string message(messageBuffer, size);\n\n    //Free the buffer.\n    LocalFree(messageBuffer);\n\n    return message;\n}\nint eval(string cmd, string &#x26;res) {\n    SECURITY_ATTRIBUTES saAttr;\n    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);\n    saAttr.bInheritHandle = TRUE;\n    saAttr.lpSecurityDescriptor = NULL;\n\n    HANDLE read = NULL;\n    HANDLE write = NULL;\n\n    //when process write in 'write' you could read from 'read'\n    if (!CreatePipe(&#x26;read, &#x26;write, &#x26;saAttr, 0)) {\n        res =\"CreatePipe Err\" ;\n        return -1;\n    }\n\n    //init PROCESS_INFORMATION\n    PROCESS_INFORMATION piProcInfo;\n    ZeroMemory(&#x26;piProcInfo, sizeof(PROCESS_INFORMATION));\n    //init STARTUPINFO set output handle of process\n    STARTUPINFOA siStartInfo;\n    ZeroMemory(&#x26;siStartInfo, sizeof(STARTUPINFO));\n    siStartInfo.cb = sizeof(STARTUPINFO);\n    siStartInfo.hStdOutput = write;\n    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;\n\n    BOOL bSuccess = FALSE;\n    bSuccess = CreateProcessA(\n        NULL,\n        (LPSTR)cmd.c_str(),     // command line\n        NULL,          // process security attributes\n        NULL,          // primary thread security attributes\n        TRUE,          // handles are inherited\n        CREATE_NO_WINDOW,// creation flags\n        NULL,          // use parent's environment\n        NULL,          // use parent's current directory\n        &#x26;siStartInfo,  // STARTUPINFO pointer\n        &#x26;piProcInfo);  // receives PROCESS_INFORMATION\n    if (!bSuccess)\n    {\n        res= GetLastErrorAsString();\n        return -1;\n    }\n\n    CloseHandle(write);\n    CloseHandle(piProcInfo.hProcess);\n    CloseHandle(piProcInfo.hThread);\n\n    //now we can read the output of process\n    DWORD dwRead;\n    char chBuf[BUFSIZE + 1];\n    stringstream ss;\n    for (;;)\n    {\n        if (!ReadFile(read, chBuf, BUFSIZE, &#x26;dwRead, NULL))\n        {\n            break;\n        }\n        if (dwRead > 0)\n        {\n            chBuf[dwRead] = '\\0';\n            ss &#x3C;&#x3C; chBuf;\n        }\n    }\n    res = ss.str();\n    return 0;\n}\n\nint main()\n{\n    string cmd = \"cmd /C echo test\";\n    string res;\n    if (eval(cmd, res)==0) {\n        cout &#x3C;&#x3C; \"eval \" &#x3C;&#x3C; cmd &#x3C;&#x3C; \" ok\" &#x3C;&#x3C; endl;\n        cout &#x3C;&#x3C; res &#x3C;&#x3C; endl;\n    }\n    else\n    {\n        cout &#x3C;&#x3C; \"eval \" &#x3C;&#x3C; cmd &#x3C;&#x3C; \" fail\" &#x3C;&#x3C; endl;\n        cout &#x3C;&#x3C; res &#x3C;&#x3C; endl;\n    }\n    cin.get();\n    return 0;\n}\n</code></pre>\n<h1>Rust</h1>\n<pre><code class=\"language-rust\">// power by https://github.com/hniksic/rust-subprocess.git\n/*\n[target.'cfg(windows)'.dependencies]\nwinapi = \"0.2\"\nkernel32-sys = \"0.2\"\n*/\n\n#[cfg(windows)]\nextern crate kernel32;\n#[cfg(windows)]\nextern crate winapi;\nuse std::ffi::OsStr;\nuse std::os::windows::ffi::OsStrExt;\nuse std::iter;\nuse std::ptr;\nuse std::mem;\n\n// OsStr to zero-terminated owned vector\nfn to_nullterm(s: &#x26;OsStr) -> Vec&#x3C;u16> {\n    s.encode_wide().chain(iter::once(0u16)).collect()\n}\n\nfn create_process(cmd: String) -> Result&#x3C;String, String> {\n    use winapi::minwinbase::{LPSECURITY_ATTRIBUTES, SECURITY_ATTRIBUTES};\n    use winapi::winbase::{CREATE_NO_WINDOW, STARTF_USESTDHANDLES};\n    use winapi::minwindef::{BOOL, DWORD};\n    use winapi::{PROCESS_INFORMATION, STARTUPINFOW};\n    use winapi::winnt::PHANDLE;\n    use std::fs::File;\n    use std::os::windows::io::{AsRawHandle, FromRawHandle};\n    use std::ffi::OsStr;\n    use std::io::Read;\n    let mut attributes = SECURITY_ATTRIBUTES {\n        nLength: mem::size_of::&#x3C;SECURITY_ATTRIBUTES>() as DWORD,\n        lpSecurityDescriptor: ptr::null_mut(),\n        bInheritHandle: true as BOOL,\n    };\n\n    let (mut r, mut w) = (ptr::null_mut(), ptr::null_mut());\n    unsafe {\n        kernel32::CreatePipe(\n            &#x26;mut r as PHANDLE,\n            &#x26;mut w as PHANDLE,\n            &#x26;mut attributes as LPSECURITY_ATTRIBUTES,\n            0,\n        )\n    };\n    let (mut read, write) = unsafe { (File::from_raw_handle(r), File::from_raw_handle(w)) };\n\n    let mut sinfo: STARTUPINFOW = unsafe { mem::zeroed() };\n    sinfo.cb = mem::size_of::&#x3C;STARTUPINFOW>() as DWORD;\n    sinfo.hStdOutput = write.as_raw_handle();\n    sinfo.dwFlags = STARTF_USESTDHANDLES;\n\n    let cmd_line = OsStr::new(&#x26;cmd);\n    let mut pinfo: PROCESS_INFORMATION = unsafe { mem::zeroed() };\n    unsafe {\n        kernel32::CreateProcessW(\n            ptr::null(),\n            to_nullterm(cmd_line).as_mut_ptr(),\n            ptr::null_mut(),  // lpProcessAttributes\n            ptr::null_mut(),  // lpThreadAttributes\n            true as BOOL,     // bInheritHandles\n            CREATE_NO_WINDOW, // dwCreationFlags\n            ptr::null_mut(),  // lpEnvironment\n            ptr::null_mut(),  // lpCurrentDirectory\n            &#x26;mut sinfo,\n            &#x26;mut pinfo,\n        )\n    };\n    unsafe {\n        kernel32::CloseHandle(write.as_raw_handle());\n    }\n    unsafe {\n        kernel32::CloseHandle(pinfo.hProcess);\n    }\n    unsafe {\n        kernel32::CloseHandle(pinfo.hThread);\n    }\n\n    let mut contents = Vec::new();\n    read.read_to_end(&#x26;mut contents).map_err(|e|e.to_string())?;\n    String::from_utf8(contents).map_err(|e| e.to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_create_process() {\n        let msg = \"test\".to_owned();\n        let res = create_process(format!(\"cmd /c echo {}\", msg));\n        assert_eq!(res, Ok(format!(\"{}\\r\\n\", msg)));\n    }\n}\n</code></pre>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/器/CreateProcess/","fileNode":"fileNode"}}