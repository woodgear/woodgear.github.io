{"data":{"markdownRemark":{"html":"<p><a href=\"https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(object-oriented_programming\">https://en.wikipedia.org/wiki/Comparison<em>of</em>programming<em>languages</em>(object-oriented_programming</a>)</p>\n<h1>l-compiler</h1>\n<h1>l-dpendency</h1>\n<p>如何使用他人的库</p>\n<ol>\n<li>原理是什么</li>\n<li>如何增加/安装/使用一个库</li>\n<li>\n<p>国内镜像(233)</p>\n<h2>tips</h2>\n</li>\n<li>远程模型/本地模块?</li>\n<li>\n<p>在局部作用域中暴露命名空间 (在一个函数内,引入某个模块的所有命名空间)</p>\n<h1>doc</h1>\n<p>如何生成文档?如何在代码中书写文档</p>\n<h1>l-test</h1>\n<p>如何测试</p>\n</li>\n</ol>\n<h1>l-io</h1>\n<h2>l-console-out</h2>\n<p>向控制台输出的能力</p>\n<h1>l-interface</h1>\n<p>interface 对类或者对数据结构作出描述,而我们根据这种事先的约定/约束 操作数据,而不用关心具体的实现, Java中的interface,C++中的虚函数,Golang中的Interfact,Rust中trait,Ts中的interface</p>\n<ol>\n<li>如何定义interface </li>\n<li>\n<p>如何实现interface</p>\n<h2>l-advance-interface</h2>\n<h3>l-interface-generic (范型)</h3>\n</li>\n</ol>\n<h1>l-async</h1>\n<p>语法层次上的对于异步的支持</p>\n<h1>函数定义 (l-function)</h1>\n<p>无论如何我们都需要某种机制让我们能够将逻辑/表达式 组合成一个上层的有语义的逻辑块,函数是第一层的封装.函数要素 1. 函数定义符 2. 函数名 3. 参数 4. 返回值</p>\n<ul>\n<li>\n<p>go [v]</p>\n<h2>函数参数定义 (l-function-args)</h2>\n<p>有些语言允许同时定义多个元素的类型</p>\n</li>\n<li>go [v]</li>\n<li>\n<p>rust [x]</p>\n<h2>tips (l-anonymous-function)</h2>\n<p>此外还有如何定义匿名函数,即闭包</p>\n<h2>函数默认参数 (l-function-default-argument)</h2>\n<h2>函数可选参数 (l-function-option-argument)</h2>\n<h1>l-var-define (变量定义)</h1>\n<p>不同的语言中定义一个变量的姿势也不同</p>\n<h2>l-var-define-var</h2>\n<h2>l-var-define-array</h2>\n<h2>l-var-define-hashmap</h2>\n<h2>l-var-define-object</h2>\n<h2>l-var-define-string</h2>\n</li>\n</ul>\n<h1>l-type-define</h1>\n<p>基本上在所有的语言中都有有关数据类型的语法\n我们该如何声明那些常见的数据类型？</p>\n<h1>结构体定义 (l-struct)</h1>\n<p>无论如何我们需要某种机制让我们能够将数据/类型 组合成一个有上层语义的数据/类型</p>\n<h2>构造结构体 (l-construct-struct)</h2>\n<h2>l-struct-mixin</h2>\n<p>组合结构体 最常见的一种是将一种类型的结构体作为另一种类型的结构体的一个fieled，当是还有种是将两个结构体merge起来,例如golang的struct mixute</p>\n<h2>匿名结构体 (l-struct-anonymous)</h2>\n<p>一些语言 类似golang允许我们定义一些匿名结构体</p>\n<h1>l-statement</h1>\n<h2>l-select</h2>\n<p>根据条件判断执行某些语句.<br>\n条件判断可以是简单的bool,也可能是模式匹配.<br>\n执行语句可能是简单的执行一次,也可能是执行完成后再循环</p>\n<h3>l-if/else</h3>\n<h3>l-loop</h3>\n<ul>\n<li>\n<p>go [v]</p>\n<h3>iterator (与loop不同iterator更加强调遍历容器)</h3>\n</li>\n</ul>\n<h1>l-common-container</h1>\n<h1>l-string</h1>\n<h2>l-string-raw</h2>\n<ol>\n<li>无转义的原生字符 类似于 rust的<code class=\"language-text\">r#””“#</code></li>\n<li>多行的字符串</li>\n</ol>\n<h2>[[l-string-fmt]]</h2>\n<p>给定一些值，如何将其构造成字符串？ 一个常用的方法是以一个字符串为模板 将值应用进去从而得到新的字符串\n不同的语言中字符串模板的写法均有所不同\nJS中是[[js-template-strings]] 除了上述所讲外 还有一个概念叫做[[js-tagged-templates]],可以搞出更多的花样.\nPython中是通过[[python-fstring]]\nRust中是通过常规的<code class=\"language-text\">&quot;xxx&quot;.format(xxx)</code>的形式</p>\n<h2>l-string-api</h2>\n<ul>\n<li>\n<p>compare-string-dict-order</p>\n<h2>array</h2>\n<h3>l-array-access-syntax</h3>\n<p>对于顺序容器的一个常见操作是 1. 获取其中某个元素 2. 获取其中一段range的引用\n一个常见的方法是使用<code class=\"language-text\">[]</code>操作符\n获取其中某个元素 [x] 如果将x的类型从usize变为isize 我们可以很方便的表示从末尾开始的索引 如<code class=\"language-text\">[-1]</code>表示最后一个\nrange也是类似[1:3]表示从1-3的这一range [1,-1]表示从index为1的到最后一个\n有些语言如python中还允许你选择step</p>\n</li>\n</ul>\n<h4>l-array-index</h4>\n<h4>l-array-range</h4>\n<p>最起码就golang和rust而言array-range的模型是统一的</p>\n<ol>\n<li>前闭后开</li>\n<li>当low,hight相等时返回空</li>\n<li>low>hight报错\n[x] golang\n[x] rust</li>\n</ol>\n<h2>quque</h2>\n<h2>map</h2>\n<h1>l-scoop</h1>\n<p>有时我们希望作用域有返回值 这样一些操作就可以包装在一个嵌套的作用域中,这样可以将逻辑封装起来,使得阅读是每一步的抽象层次都是大致相当的.\n[x] rust\n[ ] golang</p>\n<h1>l-assert</h1>\n<p>某些不可能发生的事情发生的时候 是我们不可能希望看到的 这时就要用assert 强制的作出约束</p>\n<h1>l-env</h1>\n<p>例如当前代码文件 行号 等 环境信息 方便于debug</p>\n<h1>l-dynamic-lanuange</h1>\n<h2>l-access-nest-object</h2>\n<p>在动态语言中 我们该如何如何正常(优雅而安全)的访问一个嵌套的object?</p>\n<h1>l-profile</h1>\n<p>当检测内存泄漏时 最简单的方式就是定时对mem做快照 通过对比内存快照检测泄漏点\n[go]</p>\n<h1>l-json</h1>\n<p>对于JSON的支持 语言中的某个实例 &#x3C;=>JSON </p>\n<h1>l-ffi</h1>\n<blockquote>\n<p>赞美C,你的ABI行走在世界的每个角落.\nffi 以某种方式调用其他语言的接口,或者提供接口被其他语言调用.当然了,在这个世界线上这种所谓的接口就是C的ABI.</p>\n</blockquote>\n<h2>l-call-fii</h2>\n<p>对于FFI来讲 所有权应当控制在调用者手中 调用者来负责分配内存释放内存.\n下面的echo就是一个很好的例子.写入参数/写出参数/返回值 全部齐全了.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">int</span> <span class=\"token function\">echo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>OutBuffer<span class=\"token punctuation\">,</span> size_t <span class=\"token operator\">&amp;</span>OutLen<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>InBuffer<span class=\"token punctuation\">,</span> size_t InLen<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span><span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>OutBuffer<span class=\"token punctuation\">,</span> InBuffer<span class=\"token punctuation\">,</span> InLen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>l-call-ffi-dynmaic</h3>\n<h3>l-call-ffi-static</h3>\n<h2>l-been-ffi</h2>\n<p>必须能够变成动态或者静态的c库</p>\n<h3>l-been-ffi-dynmaic</h3>\n<h3>l-been-ffi-static</h3>\n<h2>project template</h2>\n<p>使用此语言的最佳实践 各种项目的模板 如 cli,server,front server等</p>\n<h2>l-language-formal-define</h2>\n<p>准确的语法定义 类似BNF这种</p>","fields":{"slug":"/share/编程语言要素/语言要素/","disqus":{"shortname":"woodgear-blog"}},"frontmatter":{"id":"dstgtes","time":"1996-09-08T23:37:07+08:00","tag":null},"parent":{"__typename":"File","name":"语言要素","ext":".md","birthTime":"1970-01-01T00:00:00.000Z","changeTime":"2020-10-07T19:26:17.265Z","relativeDirectory":"share/编程语言要素","absolutePath":"/home/oaa/ns/share/blog/share/编程语言要素/语言要素.md"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/share/编程语言要素/语言要素/","disqus":{"shortname":"woodgear-blog"}}}