{"data":{"markdownRemark":{"html":"<h2>问</h2>\n<p>现使用SAX解析xml生成了一系列的event(流)如何从这些event中解出dom(数据)?</p>\n<p>xml如下</p>\n<pre><code class=\"language-xml\">&#x3C;root>\n&#x3C;pluginA>&#x3C;Policy>testA&#x3C;/Policy>&#x3C;/pluginA>\n&#x3C;pluginB>testB&#x3C;/pluginB>\n&#x3C;/root>\n</code></pre>\n<p>生成的event如下</p>\n<pre><code class=\"language-js\">const events = [\n    new Start('root'),\n    new Start('pluginA'),\n    new Start('Policy'),\n    new Text('testA'),\n    new End('pluginA'),\n    new Start('pluginB'),\n    new Text('testB'),\n    new End('pluginB'),\n    new End('root'),\n]\n</code></pre>\n<h2>答</h2>\n<p>这应当是个栈的结构 每次遇到Start创建一个对象 把此对象引用放到栈顶对象的child中 此对象入栈 End出栈 栈中的最后一个元素即为想要的结构</p>\n<h2>代码</h2>\n<pre><code class=\"language-js\">const expect = require('chai').expect;\nclass Start {\n    constructor(tag, attribute) {\n        this.tag = tag;\n        this.attribute = attribute || {};\n    }\n}\nclass End {\n    constructor(tag) {\n        this.tag = tag;\n    }\n}\nclass Text {\n    constructor(text) {\n        this.text = text;\n    }\n}\n\nclass Element {\n    constructor(tagName, attribute, child) {\n        this.tagName = tagName;\n        this.attribute = attribute || {};\n        this.child = child || [];\n    }\n}\n\nclass Handle {\n    constructor() {\n        this.stack = [];\n    }\n\n    create(tag, attribute) {\n        const ele = new Element(tag, attribute);\n        //first element\n        if (this.stack.length == 0) {\n            this.stack.push(ele);\n        } else {\n            this.stack[this.stack.length - 1].child.push(ele);\n        }\n        this.stack.push(ele);\n    }\n\n    text(text) {\n        this.stack[this.stack.length - 1].child.push(text);\n    }\n\n    end(tag) {\n        this.stack.pop();\n    }\n    build() {\n        return this.stack[0];\n    }\n}\n\nfunction trans(events) {\n    const ele = new Handle();\n    for (let event of events) {\n        if (event instanceof Start) {\n            ele.create(event.tag, event.attribute);\n        } else if (event instanceof Text) {\n            ele.text(event.text);\n        }\n        else if (event instanceof End) {\n            ele.end(event.tag);\n        }\n    }\n    return ele.build();\n}\n\ndescribe('Trans', () => {\n    const MockEvents = [\n        new Start('root'),\n        new Start('pluginA'),\n        new Start('Policy'),\n        new Text('testA'),\n        new End('Policy'),\n        new End('pluginA'),\n        new Start('pluginB'),\n        new Text('testB'),\n        new End('pluginB'),\n        new End('root'),\n    ];\n    it('should ok', () => {\n        let expectRes = new Element('root', {},\n            [new Element('pluginA', {},\n                [new Element('Policy', {}, ['testA'])]),\n            new Element('pluginB', {}, ['testB']),\n            ],\n        )\n        let res = trans(MockEvents);\n        expect(res).deep.eq(expectRes);\n    })\n});\n</code></pre>\n<h2>Tips</h2>\n<p>如果想要将element再转换成具体的对象也就很简单了</p>","frontmatter":{"title":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/I Want To Talk/从流中解出数据/"}}