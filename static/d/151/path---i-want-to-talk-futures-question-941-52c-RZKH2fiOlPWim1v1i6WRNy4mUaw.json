{"data":{"markdownRemark":{"html":"<p>sorry for my English. if you could not understand what I talk just point it out.<br>\nI am currently try to figure out how task::current works.<br>\nafter digging some source code. I think I understand the call stack of task::current but still sth confuse me like the title.\nthere is something I found out, correct me if I was wrong.  </p>\n<p>current use a function called get_ptr to get a pointer of BorrowedTask.the BorrowedTask  is the current task.<br>\nsource code under blow  </p>\n<pre><code class=\"language-rust\">pub fn current() -> Task {\n with(|borrowed| {\n let unpark = borrowed.unpark.to_owned();\n let events = borrowed.events.to_owned();\n\n        Task {\n            id: borrowed.id,\n            unpark: unpark,\n            events: events,\n        }\n    })\n}\nfn with&#x3C;F: FnOnce(&#x26;BorrowedTask) -> R, R>(f: F) -> R {\n unsafe {\n let task = get_ptr().expect(\"no Task is currently running\");\n assert!(!task.is_null(), \"no Task is currently running\");\n f(&#x26;*(task as *const BorrowedTask))\n    }\n}\n\nthread_local!(static CURRENT_TASK: Cell&#x3C;*mut u8> = Cell::new(ptr::null_mut()));\n\nstatic INIT: Once = ONCE_INIT;\n\npub fn get_ptr() -> Option&#x3C;*mut u8> {\n // Since this condition will always return true when TLS task storage is\n // used (the default), the branch predictor will be able to optimize the\n // branching and a dynamic dispatch will be avoided, which makes the\n // compiler happier.\n if core::is_get_ptr(0x1) {\n        Some(CURRENT_TASK.with(|c| c.get()))\n    } else {\n        core::get_ptr()\n    }\n}\n</code></pre>\n<p>so the question is who and when to set/update/init the CURRENT_TASK.<br>\nthis is a function called set, seems the only way to do those stuff.</p>\n<pre><code class=\"language-rust\"> \nfn tls_slot() -> *const Cell&#x3C;*mut u8> {\n    CURRENT_TASK.with(|c| c as *const _)\n}\n\npub fn set&#x3C;'a, F, R>(task: &#x26;BorrowedTask&#x3C;'a>, f: F) -> R\n where F: FnOnce() -> R\n{\n // Lazily initialize the get / set ptrs\n //\n // Note that we won't actually use these functions ever, we'll instead be\n // testing the pointer's value elsewhere and calling our own functions.\n    INIT.call_once(|| unsafe {\n let get = mem::transmute::&#x3C;usize, _>(0x1);\n let set = mem::transmute::&#x3C;usize, _>(0x2);\n init(get, set);\n    });\n\n // Same as above.\n if core::is_get_ptr(0x1) {\n struct Reset(*const Cell&#x3C;*mut u8>, *mut u8);\n\n impl Drop for Reset {\n            #[inline]\n fn drop(&#x26;mut self) {\n unsafe {\n                    (*self.0).set(self.1);\n                }\n            }\n        }\n\n unsafe {\n let slot = tls_slot();\n let _reset = Reset(slot, (*slot).get());\n            (*slot).set(task as *const _ as *mut u8);\n f()\n        }\n    } else {\n        core::set(task, f)\n    }\n}\n</code></pre>\n<p>and then the question is who calls the set function.<br>\nand I find than I could not find whom to call set.<br>\nthe calling chain seems broken.<br>\nafter some search </p>\n<blockquote>\n<p> It is initialized by a reactor before polling a task and as discussed  above, may be overridden by specific futures within the task </p>\n</blockquote>\n<p>I found some word come from <a href=\"https://gist.github.com/Diggsey/6f924bf3f741bcdffd240faee102fe92\">Looking into the Future</a></p>\n<p>It seems to say that is there some code under tokio-reactor to called the set function, but after a search in tokio I still could not find anything about that.</p>\n<p>please help me with that.</p>","frontmatter":{"title":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/I Want To Talk/futures/question/"}}