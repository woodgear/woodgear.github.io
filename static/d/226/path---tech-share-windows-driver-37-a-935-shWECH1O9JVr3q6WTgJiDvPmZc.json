{"data":{"markdownRemark":{"html":"<h1>搭建调试环境</h1>\n<p>我们的目标是搭建一个能进行方便调试的驱动开发环境,所谓的方便调试,应该满足以下几点</p>\n<ol>\n<li>能够通过命令行的方式编译出驱动</li>\n<li>能够以简单的方式(命令行)将驱动文件部署到测试机上</li>\n<li>能够以简单的方式(命令行)在测试机上启动驱动</li>\n<li>能够在开发机上单步调试 打断点</li>\n<li>能够在开发机上从驱动入口出断点调试</li>\n<li>测试机开机自启断点</li>\n</ol>\n<p>简单的讲就是我们决对不应当在被调试机上手动执行任何操作\n被调试机应该就只是一个简单的viewer而已\n根据我已有的概念 大概的思路是 使用windbg的远程调试做到在开发机上调试</p>\n<h1>原理</h1>\n<p>从win7开始所有的64的驱动都需要签名 这是确定的 也就是说假设编译出一个驱动(右键观察属性 数字签名一列) 没有做任何签名的步骤 不论对windows做任何配置 都无法让其正常加载启动(sc start) 但是对如何校验签名 windows 放宽了限制,在实际的生产环境中windows会校验所有签名的所有者(必须有证书?) 证书必须能够溯源到windows自己,也就是讲必须送给windows签名,但同时也提供了开关让我们不进行校验证书这一步.简单的讲就是我们可以给驱动<a href=\"\">打上测试签名</a> 在<a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option\">开启测试模式</a>的电脑上运行</p>\n<h1>运行驱动</h1>\n<p>在开发中运行驱动需要测试签名的驱动运行在测试模式的电脑上 也就是讲需要在host上调用signtool在targer上<code class=\"language-text\">bcdedit /set testsigning on</code>然后重启</p>\n<h1>双机调试</h1>\n<h1>测试签名</h1>\n<p>微软签名的本质原因是所有的电脑中都有windows的证书,所以想要测试 我们的电脑中也要装一个自己mock的证书\n<a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/install/creating-test-certificates\">https://docs.microsoft.com/en-us/windows-hardware/drivers/install/creating-test-certificates</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">makecert -r -pe -ss PrivateCertStore -n CN=Contoso.com(Test) -eku 1.3.6.1.5.5.7.3.3 ContosoTest.cer</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>上述命令会把PrivateCertStore这个证书装到电脑中 可以通过certmgr.msc 看到</p>\n<h2>嵌入式签名</h2>\n<p><a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/install/test-signing-a-driver-through-an-embedded-signature\">https://docs.microsoft.com/en-us/windows-hardware/drivers/install/test-signing-a-driver-through-an-embedded-signature</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Signtool sign /v /fd sha256 /s PrivateCertStore /n Contoso.com(Test) /t http://timestamp.digicert.com amd64\\toaster.sys</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h1>双机调试</h1>\n<div class=\"gatsby-highlight\" data-language=\"bat\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bat line-numbers\"><code class=\"language-bat\">bcdedit /debug on \n\nrem 设置端口 这里n指的是com接口\nrem bcdedit /dbgsettings\n\nrem https://resources.infosecinstitute.com/kernel-debugging-qemu-windbg/#gref\n\n完成之后重启桌面右下角有水印</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1>ubuntu kvm dev-windows driver widnows</h1>\n<p>两台电脑之间通过串口通信 而kvm模拟的串口可以互相连接(tcp 相同端口 client side mode和server side 两个虚拟机开启串行通信接口 一个作为server 一个作为client\nclient虚拟机在启动时会尝试连接server所以必须先启动server\nmode)</p>\n<h1>经典双机调试 host window target virtual box windows</h1>\n<p>设置串口的时候不要选择使用已有的串口\npipename 格式为 \\.\\pipe\\PipeName</p>\n<h1>windbg cmdline</h1>\n<div class=\"gatsby-highlight\" data-language=\"bat\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bat line-numbers\"><code class=\"language-bat\">set WINDBG_PATH=&quot;C:\\WinDDK\\7600.16385.1\\Debuggers\\windbg.exe&quot;\n# COM1 是开发机的COM口 baud 必须和调试机对应COM口的baud一致\n\n# [symbol-path](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/symbol-path)\n# 从https://msdl.microsoft.com/download/symbols加载符号并缓存到本地\n\n  -k com:port=\\\\.\\pipe\\win7,baud=115200 -y cache*;srv*https://msdl.microsoft.com/download/symbols</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1>符号加载</h1>\n<p>需要翻墙 设置环境变量<em>NT</em>SYMBOL_PROXY</p>\n<h1>驱动执行环境</h1>\n<h2>猜想</h2>\n<p>除非特别创建线程 驱动代码运行在用户线程的内核空间,例如写Fd捕获到文件读写时 驱动回调代码就运行在发起文件读写的那个进程中(只不过进入了内核态)\n所以假设我有个文件回调 打出<code class=\"language-text\">PsGetCurrentProcessId</code>同时有个进程一直在write file + print current pid 那么两个pid应当是能对应的</p>\n<h1>windbg dbgprint</h1>\n<p>在windbg中看dbgprint\n<code class=\"language-text\">ed nt!Kd_Default_Mask 8</code></p>\n<h1>源码调试</h1>\n<p>加载完符号设置好srcpath之后 可能要.open xx来开启源码窗口</p>\n<h1>pdb reload</h1>\n<p>为了解决pdb占用问题 使用symstore将pdb索引到其他目录再用http-server</p>\n<div class=\"gatsby-highlight\" data-language=\"bat\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bat line-numbers\"><code class=\"language-bat\">set local_symbol_server_path=C:\\Users\\18754\\work\\driver\\my_symb_server\nset pdb_dir_path=C:\\Users\\18754\\work\\driver\\winpcap_resource\\winpcap\\packetNtx\\driver\\bin\\amd64\nset symstore_exe_path=&quot;C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\symstore.exe&quot;\n%symstore_exe_path%  add /s %local_symbol_server_path%  /compress /r /f %pdb_dir_path%\\*.pdb /t npf</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>build.bat 编译驱动 自动做test sign,用symstore加入到local symbol server中,simple http server 提供网络访问, windbg.bat 启动windbg 设置好symbol server 使用vboxmanager控制vm重启,虚拟机中自启动bot-server,host中使用bot-client连接控制更新驱动\n这样基本就是一个完美的debug流程了</p>\n<h1>create service</h1>\n<div class=\"gatsby-highlight\" data-language=\"bat\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bat line-numbers\"><code class=\"language-bat\">sc create $name type= kernel binPath= $Path</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h1>debug print</h1>\n<p><a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/reading-and-filtering-debugging-messages\">debug level</a>\nDbgPrintEx  允许我们设置log的level和kind,在调试时我们能设置对应kind的mask 从而允许我们过滤log</p>\n<div class=\"gatsby-highlight\" data-language=\"bat\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bat line-numbers\"><code class=\"language-bat\">NTSYSAPI ULONG DbgPrintEx(\n  ULONG ComponentId,\n  ULONG Level,\n  PCSTR Format,\n  ...   \n);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>ComponentId 标识的组件的类型(kind) 可以使用下面几个定义在wdk Dpfilter.h中的常量</p>\n<div class=\"gatsby-highlight\" data-language=\"bat\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bat line-numbers\"><code class=\"language-bat\">IHVVIDEO Video driver\n\nIHVAUDIO Audio driver\n\nIHVNETWORK Network driver\n\nIHVSTREAMING Kernel streaming driver\n\nIHVBUS Bus driver\n\nIHVDRIVER Any other type of driver</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bat\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bat line-numbers\"><code class=\"language-bat\">//ed nt!Kd_IHVDRIVER_Mask 0x4d\ned nt!Kd_{ComponentId}_Mask 0x{Mask}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>使用ed设置对应ComponentId的Mask <code class=\"language-text\">dd nt!Kd_{ComponentId}_Mask</code>查看设置的值\n我们在可以在电脑上设置对应component的filtermask 来决定那些信息是会被显示出来的\n如果Mask是A Level是B,A&#x26;B!=0 则会显示也就是说Mask和Level的二进制中必须至少有一位都是<code class=\"language-text\">1</code>才能显示log</p>\n<h1><a href=\"https://docs.microsoft.com/en-us/sysinternals/downloads/winobj\">winobj</a></h1>\n<p>可以用来检查device有没有被创建成功</p>\n<h1>deivce</h1>\n<p>如果没有delete device的话可能会无法重新安装</p>\n<h1>测试</h1>\n<p>安装 启动 卸载 升级</p>\n<p>通信</p>\n<p>内存?</p>","fields":{"slug":"/tech-share/windows-driver/","disqus":{"shortname":"woodgear-blog"}},"frontmatter":{"id":"hlx854c","time":"1996-09-08T23:37:07+08:00","tag":null},"parent":{"__typename":"File","name":"windows-driver","ext":".md","birthTime":"1970-01-01T00:00:00.000Z","changeTime":"2020-11-26T15:06:53.437Z","relativeDirectory":"tech-share","absolutePath":"/home/oaa/ns/share/blog/tech-share/windows-driver.md"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/tech-share/windows-driver/","disqus":{"shortname":"woodgear-blog"}}}