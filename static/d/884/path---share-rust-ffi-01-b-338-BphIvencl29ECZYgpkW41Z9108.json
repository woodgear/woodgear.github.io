{"data":{"markdownRemark":{"html":"<blockquote>\n<p>通过channel来通信,不要通过共享变量来通信\n不同语言之间的调用就目前来看,dll或者讲c的ABI是最为稳固的,为了提供这个接口,我们不得不写出一些胶水代码,将我们的语意转换成dll的接口.但dll的接口实际上无关紧要的,我们想要的仅仅是跨语言调用这个结果罢了,这种抽象在某种程度上与微服务是类似的</p>\n</blockquote>\n<h1>c 调用 rust dll</h1>\n<p>常见的操作是rust编译成dll,c/c++ 通过操作dll来完成对rust的操作\n一般来讲,这样就涉及到两个问题</p>\n<ol>\n<li>如何将数据传递到rust</li>\n<li>\n<p>如何从rust读取出数据\n也就是说作为一个dll的通用接口是</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">pass_to_rust</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> buff<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> bufflen<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">read_from_rust</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> buff<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> writeed_bufflen<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> max_len<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h2>pass to rust</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">pass_to_rust</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> buff<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> bufflen<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>buff指的是我们在c中准备好的想传递过去的内存的地址 bufflen 是总长度\n在这种场景中 我们总是能完整的准备好所有想要传递过去的数据</p>\n<h2>read from rust</h2>\n</li>\n</ol>\n<h1>combine</h1>\n<p>实际上这两者是相同的 在很多时候我们既要读 又要写 而这就是rpc\n在进一步的讲 我们可以将所有dll的接口写出protobuf的形式</p>","fields":{"slug":"/share/rust-ffi/","disqus":{"shortname":"woodgear-blog"}},"frontmatter":{"id":"pcqgi2i","time":"1996-09-08T23:37:07+08:00","tag":"rust,ffi,dll-as-interface,c/c++"},"parent":{"__typename":"File","name":"rust-ffi","ext":".md","birthTime":"1970-01-01T00:00:00.000Z","changeTime":"2020-11-26T15:05:48.118Z","relativeDirectory":"share","absolutePath":"/home/oaa/sm/ns/share/blog/share/rust-ffi.md"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/share/rust-ffi/","disqus":{"shortname":"woodgear-blog"}}}