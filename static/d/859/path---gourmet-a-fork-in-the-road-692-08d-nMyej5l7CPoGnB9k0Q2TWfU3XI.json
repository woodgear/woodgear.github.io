{"data":{"markdownRemark":{"html":"<p><a href=\"https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf\">pdf</a></p>\n<p>路径依赖的又一实例,fork本来确实就蛮奇怪的,竟然是微软的人来发文章讲这件事,而不是unix社区自己的人来修正,真的是有点打脸.</p>\n<blockquote>\n<p>什么叫大道至简,互相组合啊 --微软  </p>\n</blockquote>\n<p>后面的几个解决方案中<code class=\"language-text\">spawn</code>(实际就是CreateProcess)看起来还有点意思.其他的几个感觉是修修补补.  </p>\n<p>不过现在最大的问题在于线程这个概念是否要做出修正了.原本是自然而然的process->thread 这条路 不过现在看起来要么显式的保留proccess这个概念,用协程走golang的路.要么是像rust走多线程事件驱动的路(这条路看来也只有rust能走 除非大家都上所有权这种能保证单一所有权的机制)</p>\n<p>引申起来有一个值得深思的问题是</p>\n<p>如何保证向后兼容 或者讲如何最小化替换的成本和路径依赖 </p>\n<p>剪断耦合所有人走kvm的路是我所唯一能想到的</p>","fields":{"slug":"/gourmet/a-fork-in-the-road/","disqus":{"shortname":"woodgear-blog"}},"frontmatter":{"id":"783aee9","time":"2020-08-03T04:35:14+08:00","tag":null},"parent":{"__typename":"File","name":"a-fork-in-the-road","ext":".md","birthTime":"1970-01-01T00:00:00.000Z","changeTime":"2020-09-26T05:07:01.914Z","relativeDirectory":"gourmet","absolutePath":"/home/oaa/ns/share/blog/gourmet/a-fork-in-the-road.md"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/gourmet/a-fork-in-the-road/","disqus":{"shortname":"woodgear-blog"}}}