{"data":{"markdownRemark":{"html":"<h1>ACID</h1>\n<h2>原子性</h2>\n<p>对应数据库来讲只有事务这个概念,没有更细微的操作.不能出现做到一半的情况.</p>\n<h2>一致性</h2>\n<p>在处理事务时不能出BUG导致数据库本身的破坏.</p>\n<h2>隔离性</h2>\n<p>对于一个正在执行的事务来讲,好像整个数据库是被其独占一样.</p>\n<h2>持久性</h2>\n<p>事务完成了就是完成了 crash/断电/其他异常出现后,恢复时也要保证这一点.</p>\n<h1>缓存管理</h1>\n<p>数据库的一大麻烦之处就在于要最优化磁盘/内存/CPU/网络,简单的讲就是最好重写操作系统 (笑)</p>\n<p>这里的缓存管理实际上就是面向数据库操作优化的页缓存</p>\n<h2>5.1.3 在缓存中锁定页</h2>\n<p>某些文件(页)在使用中因为设计的原因会一直保持\"高温\"的状态,例如根节点的几个页.我们可以选择将其Pin在内存中</p>\n<h2>5.1.4 页置换</h2>\n<p>这个水晶球怎么看怎么像机器学习 (望天)\n数据是有的 (真正的页缓存未命中的次数) 判断函数也是有的 (应用了新的策略后是否减小了缓存穿透)</p>\n<h3>FIFO/LRU</h3>\n<p>先入先出: 维护页缓存列表(加到最后),满时干掉第一个\n最后访问时间: 访问时维护页缓存列表(每次访问赋予某页权重) 满时干掉权重最低的 <a href=\"https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/\">LRU实现</a></p>\n<h4>Belady现象</h4>\n<p>在我看来Belady现象的本质原因在于,FIFO根本就不是一个有意义的置换算法,只不过是置换的一种方式罢了,没有考虑置换的意义是什么(减少置换).从实践的角度上讲,正好会越换越遭.</p>\n<h3>CLOCK</h3>\n<p><a href=\"https://www.cnblogs.com/wingsless/p/12295246.html\">clock讲解</a>\n<a href=\"https://www.codenong.com/cs105272624/\">clock讲解</a>\n实际上感觉是对LRU在工程上的优化.在不使用哈希表的情况下减少了遍历的次数</p>\n<h3>LFU  (最近最少使用)</h3>\n<p>访问累计频率, 满时干掉频率最低的 </p>\n<h2>5.2</h2>\n<p>物理日志概念对应的应该是快照</p>\n<h2>5.3 并发控制</h2>\n<h3>异常</h3>\n<p>下面是报菜名阶段</p>\n<h3>脏读</h3>\n<h3>幻读</h3>\n<h3>不可重复读</h3>\n<h4>丢失更新</h4>\n<h4>脏写</h4>\n<h4>写倾斜</h4>\n<h2>并发控制</h2>","fields":{"slug":"/baseball/数据库系统内幕/c5-事务的处理与恢复/","disqus":{"shortname":"woodgear-blog"}},"frontmatter":{"id":"d90c293","time":"2020-08-10T23:04:17+08:00","tag":null},"parent":{"__typename":"File","name":"c5-事务的处理与恢复","ext":".md","birthTime":"1970-01-01T00:00:00.000Z","changeTime":"2020-11-26T15:05:48.118Z","relativeDirectory":"baseball/数据库系统内幕","absolutePath":"/home/oaa/sm/ns/share/blog/baseball/数据库系统内幕/c5-事务的处理与恢复.md"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/baseball/数据库系统内幕/c5-事务的处理与恢复/","disqus":{"shortname":"woodgear-blog"}}}