<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8"/>
            <link rel="stylesheet" href="..\..\common/default/style.css">
            <link rel="stylesheet" href="..\..\common/highlight/styles/solarized-dark.css">
            <link rel="stylesheet" type="text/css" href="..\..\common/math/katex/katex.min.css">
            <link rel="stylesheet" type="text/css" href="..\..\common/label/label.min.css">
            <script src="..\..\common/script/util.js"></script>
            <title>actix</title>
            </head>
            <body>
            <div class="content">
            <header id="meta">
        <div id="tag" class="ui labels">
        <a class="ui label" id="time_ago">Mon Jan 28 2019 00:43:45 GMT+0800 (GMT+08:00)</a>
        <a class="ui label">I Want To Talk</a>
        
        </div>
    </header>
            <article>
            <h1>为什么能够通过addres 来send msg</h1>
<p>contextimpl 中的poll中执行力self.mailbox.poll(self,act) 其中一直在读msg然后执行msg的handle方法 实际上就接收到了Msg
每个addres 通过Arc共享一份内存一直在push msg</p>
<h1>AddressSenderProducter的Send方法在做什么?</h1>
<p>递增num_senders并构造AddressSender
只不过多线程问题 所以用了原子类型操作而已</p>
<h1>task current 在做什么</h1>
<p>目前acti使用的时future 1.0 + tokio 1.x 并没有搞懂里面具体的逻辑 不过大意就是获得了一个当前线程的waker 以便在后面通过notify通知到对应的actor 可以参照 
<a href="../aync_book">rust async book</a>
中的例子就懂了</p>
<h1>当Actor启动时发生了什么</h1>
<p>如actix.pdf</p>
<h1>当我们在Handle Msg 时通过ctx 自己给自己notify 一个msg时 我们做了什么</h1>
<p>类似于此的函数实质就是直接调用spawn</p>
<pre class="hlcode"><code>    <span class="hljs-comment">/// Sends the message `msg` to self.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>&lt;M&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, msg: M)
    <span class="hljs-keyword">where</span>
        A: Handler&lt;M&gt;,
        M: Message + <span class="hljs-symbol">'static</span>,
    {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.state() == ActorState::Stopped {
            error!(<span class="hljs-string">"Context::notify called for stopped actor."</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">self</span>.spawn(ActorMessageItem::new(msg));
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify_later</span></span>&lt;M&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, msg: M, after: Duration) -&gt; SpawnHandle
    <span class="hljs-keyword">where</span>
        A: Handler&lt;M&gt;,
        M: Message + <span class="hljs-symbol">'static</span>,
    {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.state() == ActorState::Stopped {
            error!(<span class="hljs-string">"Context::notify_later called for stopped actor."</span>);
            SpawnHandle::<span class="hljs-keyword">default</span>()
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">self</span>.spawn(ActorDelayedMessageItem::new(msg, after))
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">run_later</span></span>&lt;F&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, dur: Duration, f: F) -&gt; SpawnHandle
    <span class="hljs-keyword">where</span>
        F: <span class="hljs-built_in">FnOnce</span>(&amp;<span class="hljs-keyword">mut</span> A, &amp;<span class="hljs-keyword">mut</span> A::Context) + <span class="hljs-symbol">'static</span>,
    {
        <span class="hljs-keyword">self</span>.spawn(TimerFunc::new(dur, f))
    }

    <span class="hljs-comment">/// Spawns a job to execute the given closure periodically, at a</span>
    <span class="hljs-comment">/// specified fixed interval.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">run_interval</span></span>&lt;F&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, dur: Duration, f: F) -&gt; SpawnHandle
    <span class="hljs-keyword">where</span>
        F: <span class="hljs-built_in">FnMut</span>(&amp;<span class="hljs-keyword">mut</span> A, &amp;<span class="hljs-keyword">mut</span> A::Context) + <span class="hljs-symbol">'static</span>,
    {
        <span class="hljs-keyword">self</span>.spawn(IntervalFunc::new(dur, f).finish())
    }
}<code></pre>
<p>至于spawn 本身则是将这个这个future丢到了contextimpl的items中可以参见ContextFut的poll 这里又去poll了self.items实际上就是执行了一下这些fututre</p>
<pre class="hlcode"><code>    <span class="hljs-meta">#[inline]</span>
    <span class="hljs-comment">/// Spawn new future to this context.</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">spawn</span></span>&lt;F&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, fut: F) -&gt; SpawnHandle
    <span class="hljs-keyword">where</span>
        F: ActorFuture&lt;Item = (), Error = (), Actor = A&gt; + <span class="hljs-symbol">'static</span>,
    {
        <span class="hljs-keyword">let</span> handle = <span class="hljs-keyword">self</span>.handles[<span class="hljs-number">0</span>].next();
        <span class="hljs-keyword">self</span>.handles[<span class="hljs-number">0</span>] = handle;
        <span class="hljs-keyword">let</span> fut: <span class="hljs-built_in">Box</span>&lt;ActorFuture&lt;Item = (), Error = (), Actor = A&gt;&gt; = <span class="hljs-built_in">Box</span>::new(fut);
        <span class="hljs-keyword">self</span>.items.push((handle, fut));
        handle
    }<code></pre>
<h1>当我们获得一个actor的address 并通过这个address send一个msg时 我们做了什么</h1>
<p>每一个Actor的address实际上共享一个队列 send msg 时实际上就是将msg丢到Actor的message_queue中并且去notify这个Actor</p>
<pre class="hlcode"><code><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSender</span></span>&lt;A: Actor&gt; {
    inner: Arc&lt;Inner&lt;A&gt;&gt;,
    <span class="hljs-comment">// 省略</span>
}
<span class="hljs-keyword">impl</span>&lt;A: Actor&gt; AddressSender&lt;A&gt; {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send</span></span>&lt;M&gt;(&amp;<span class="hljs-keyword">self</span>, msg: M) -&gt; <span class="hljs-built_in">Result</span>&lt;Receiver&lt;M::<span class="hljs-built_in">Result</span>&gt;, SendError&lt;M&gt;&gt;
    <span class="hljs-keyword">where</span>
        A: Handler&lt;M&gt;,
        A::Context: ToEnvelope&lt;A, M&gt;,
        M::<span class="hljs-built_in">Result</span>: <span class="hljs-built_in">Send</span>,
        M: Message + <span class="hljs-built_in">Send</span>,
    {
        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.poll_unparked(<span class="hljs-literal">false</span>).is_ready() {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(SendError::Full(msg));
        }
        <span class="hljs-keyword">let</span> park_self = <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.inc_num_messages() {
            <span class="hljs-literal">Some</span>(park_self) =&gt; park_self,
            <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(SendError::Closed(msg)),
        };

        <span class="hljs-keyword">if</span> park_self {
            <span class="hljs-keyword">self</span>.park(<span class="hljs-literal">true</span>);
        }
        <span class="hljs-keyword">let</span> (tx, rx) = sync_channel();
        <span class="hljs-keyword">let</span> env = &lt;A::Context <span class="hljs-keyword">as</span> ToEnvelope&lt;A, M&gt;&gt;::pack(msg, <span class="hljs-literal">Some</span>(tx));
        <span class="hljs-keyword">self</span>.queue_push_and_signal(env);
        <span class="hljs-literal">Ok</span>(rx)
    }
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">queue_push_and_signal</span></span>(&amp;<span class="hljs-keyword">self</span>, msg: Envelope&lt;A&gt;) {
        <span class="hljs-keyword">self</span>.inner.message_queue.push(msg);
        <span class="hljs-keyword">self</span>.signal();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">signal</span></span>(&amp;<span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">let</span> task = {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> recv_task = <span class="hljs-keyword">self</span>.inner.recv_task.lock();
            <span class="hljs-keyword">if</span> recv_task.unparked {
                <span class="hljs-keyword">return</span>;
            }

            recv_task.unparked = <span class="hljs-literal">true</span>;
            recv_task.task.take()
        };

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(task) = task {
            task.notify();
        }
    }
}<code></pre>
<p>剩下的问题就是address是怎么来的
1. Actor启动时返回的Address</p>
<pre class="hlcode"><code><span class="hljs-keyword">impl</span>&lt;A&gt; Context&lt;A&gt;
<span class="hljs-keyword">where</span>
    A: Actor&lt;Context = <span class="hljs-keyword">Self</span>&gt;,
{
    <span class="hljs-meta">#[inline]</span>
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; Context&lt;A&gt; {
        <span class="hljs-keyword">let</span> mb = Mailbox::<span class="hljs-keyword">default</span>();
        Context {
            parts: ContextParts::new(mb.sender_producer()),
            mb: <span class="hljs-literal">Some</span>(mb),
        }
    }
    <span class="hljs-meta">#[inline]</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">run</span></span>(<span class="hljs-keyword">self</span>, act: A) -&gt; Addr&lt;A&gt; {
        <span class="hljs-keyword">let</span> fut = <span class="hljs-keyword">self</span>.into_future(act);
        <span class="hljs-keyword">let</span> addr = fut.address();
        Arbiter::spawn(fut);
        addr
    }

}
<span class="hljs-keyword">impl</span>&lt;A, C&gt; ContextFut&lt;A, C&gt;
<span class="hljs-keyword">where</span>
    C: AsyncContextParts&lt;A&gt;,
    A: Actor&lt;Context = C&gt;,
{
        <span class="hljs-meta">#[inline]</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">address</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; Addr&lt;A&gt; {
        <span class="hljs-keyword">self</span>.mailbox.address()
    }
}
<span class="hljs-keyword">impl</span>&lt;A&gt; Mailbox&lt;A&gt;
<span class="hljs-keyword">where</span>
    A: Actor,
    A::Context: AsyncContext&lt;A&gt;,
{
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">address</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; Addr&lt;A&gt; {
        Addr::new(<span class="hljs-keyword">self</span>.msgs.sender())
    }
}<code></pre>
<p>问题就是MailBox的msgs到底是什么</p>
<pre class="hlcode"><code><span class="hljs-keyword">impl</span>&lt;A&gt; <span class="hljs-built_in">Default</span> <span class="hljs-keyword">for</span> Mailbox&lt;A&gt;
<span class="hljs-keyword">where</span>
    A: Actor,
    A::Context: AsyncContext&lt;A&gt;,
{
    <span class="hljs-meta">#[inline]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">default</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">let</span> (_, rx) = channel::channel(DEFAULT_CAPACITY);
        Mailbox { msgs: rx }
    }
}<code></pre>
<p>channel又是一个很麻烦的东西</p>
<pre class="hlcode"><code><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">channel</span></span>&lt;A: Actor&gt;(buffer: <span class="hljs-built_in">usize</span>) -&gt; (AddressSender&lt;A&gt;, AddressReceiver&lt;A&gt;) {
    <span class="hljs-comment">// Check that the requested buffer size does not exceed the maximum buffer</span>
    <span class="hljs-comment">// size permitted by the system.</span>
    <span class="hljs-built_in">assert!</span>(buffer &lt; MAX_BUFFER, <span class="hljs-string">"requested buffer size too large"</span>);

    <span class="hljs-keyword">let</span> inner = Arc::new(Inner {
        buffer: AtomicUsize::new(buffer),
        state: AtomicUsize::new(INIT_STATE),
        message_queue: Queue::new(),
        parked_queue: Queue::new(),
        num_senders: AtomicUsize::new(<span class="hljs-number">1</span>),
        recv_task: Mutex::new(ReceiverTask {
            unparked: <span class="hljs-literal">false</span>,
            task: <span class="hljs-literal">None</span>,
        }),
    });

    <span class="hljs-keyword">let</span> tx = AddressSender {
        inner: Arc::clone(&amp;inner),
        sender_task: Arc::new(Mutex::new(SenderTask::new())),
        maybe_parked: Arc::new(AtomicBool::new(<span class="hljs-literal">false</span>)),
    };

    <span class="hljs-keyword">let</span> rx = AddressReceiver { inner };

    (tx, rx)
}<code></pre>
<p>在这里我们可以看到Inner终于被创建出来的 下面的无论是sender 还是sender_producer 实质上使用的都是同一份inner 也就是说通过Actor的address() 就能够将Msg丢到Actor的MailBox中这样在Actor被poll时他就会通过self.mailbox.poll()来调用真正的处理函数</p>
<pre class="hlcode"><code><span class="hljs-keyword">impl</span>&lt;A: Actor&gt; AddressReceiver&lt;A&gt; {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">sender</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; AddressSender&lt;A&gt; {
        <span class="hljs-comment">// this code same as Sender::clone</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> curr = <span class="hljs-keyword">self</span>.inner.num_senders.load(SeqCst);

        <span class="hljs-keyword">loop</span> {
            <span class="hljs-comment">// If the maximum number of senders has been reached, then fail</span>
            <span class="hljs-keyword">if</span> curr == <span class="hljs-keyword">self</span>.inner.max_senders() {
                <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"cannot clone `Sender` -- too many outstanding senders"</span>);
            }

            <span class="hljs-keyword">let</span> next = curr + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">let</span> actual = <span class="hljs-keyword">self</span>.inner.num_senders.compare_and_swap(curr, next, SeqCst);

            <span class="hljs-comment">// The ABA problem doesn't matter here. We only care that the</span>
            <span class="hljs-comment">// number of senders never exceeds the maximum.</span>
            <span class="hljs-keyword">if</span> actual == curr {
                <span class="hljs-keyword">return</span> AddressSender {
                    inner: Arc::clone(&amp;<span class="hljs-keyword">self</span>.inner),
                    sender_task: Arc::new(Mutex::new(SenderTask::new())),
                    maybe_parked: Arc::new(AtomicBool::new(<span class="hljs-literal">false</span>)),
                };
            }

            curr = actual;
        }
    }

    <span class="hljs-comment">/// Creates the sender producer.</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">sender_producer</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; AddressSenderProducer&lt;A&gt; {
        AddressSenderProducer {
            inner: <span class="hljs-keyword">self</span>.inner.clone(),
        }
    }
}
## ReceiverTask 中的task什么时候被设置进去的
初始化时为none在AddressReceiver被poll时 (mailbox被poll时) 的try_park中被设置
也就是在Actor第一次被Poll时设置 也就是Arbiter::spawn时被设置
```rust
<span class="hljs-keyword">impl</span>&lt;A: Actor&gt; Stream <span class="hljs-keyword">for</span> AddressReceiver&lt;A&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = Envelope&lt;A&gt;;
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = ();

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; Poll&lt;<span class="hljs-built_in">Option</span>&lt;Self::Item&gt;, Self::Error&gt; {
        <span class="hljs-keyword">loop</span> {
            <span class="hljs-comment">// Try to read a message off of the message queue.</span>
            <span class="hljs-keyword">let</span> msg = <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.next_message() {
                Async::Ready(msg) =&gt; msg,
                Async::NotReady =&gt; {
                    <span class="hljs-comment">// There are no messages to read, in this case, attempt to</span>
                    <span class="hljs-comment">// park. The act of parking will verify that the channel is</span>
                    <span class="hljs-comment">// still empty after the park operation has completed.</span>
                    <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.try_park() {
                        TryPark::Parked =&gt; {
                            <span class="hljs-comment">// The task was parked, and the channel is still</span>
                            <span class="hljs-comment">// empty, return NotReady.</span>
                            <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(Async::NotReady);
                        }
                        TryPark::NotEmpty =&gt; {
                            <span class="hljs-comment">// A message has been sent while attempting to</span>
                            <span class="hljs-comment">// park. Loop again, the next iteration is</span>
                            <span class="hljs-comment">// guaranteed to get the message.</span>
                            <span class="hljs-keyword">continue</span>;
                        }
                    }
                }
            };

            <span class="hljs-comment">// If there are any parked task handles in the parked queue, pop</span>
            <span class="hljs-comment">// one and unpark it.</span>
            <span class="hljs-keyword">self</span>.unpark_one();

            <span class="hljs-comment">// Decrement number of messages</span>
            <span class="hljs-keyword">self</span>.dec_num_messages();

            <span class="hljs-comment">// Return the message</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(Async::Ready(msg));
        }
    }
}
<span class="hljs-keyword">impl</span>&lt;A: Actor&gt; AddressReceiver&lt;A&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">try_park</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; TryPark {
        <span class="hljs-comment">// First, track the task in the `recv_task` slot</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> recv_task = <span class="hljs-keyword">self</span>.inner.recv_task.lock();

        <span class="hljs-keyword">if</span> recv_task.unparked {
            <span class="hljs-comment">// Consume the `unpark` signal without actually parking</span>
            recv_task.unparked = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">return</span> TryPark::NotEmpty;
        }

        recv_task.task = <span class="hljs-literal">Some</span>(task::current());
        TryPark::Parked
    }
}<code></pre>
<p>至此一切就已经联系起来了
当我们向adr中send msg 时实际上在向这个Actor的mailbox中的message_queue中推Envelope </p>
<p>并且notify下Actor的Task因为Actor的第一次被poll就会设置task所以send了一个msg时能够找到Actor的task并去notify他</p>
<h1>为什么Actor启动必须要System?</h1>
<h1>Service 是如何工作的</h1>
<h1>如何将Actor启动在不同的线程中</h1>
<h1>当某个Actor阻塞时 之前在其中设置的Timer会有什么样的表现行为 为什么</h1>
            </article>
            </div>
            <body>
            <script src="..\..\common/script/fix.js"></script>
            </html>