<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8"/>
            <link rel="stylesheet" href="..\..\..\common/default/style.css">
            <link rel="stylesheet" href="..\..\..\common/highlight/styles/solarized-dark.css">
            <link rel="stylesheet" type="text/css" href="..\..\..\common/math/katex/katex.min.css">
            <link rel="stylesheet" type="text/css" href="..\..\..\common/label/label.min.css">
            <script src="..\..\..\common/script/util.js"></script>
            <title>question</title>
            </head>
            <body>
            <div class="content">
            <header id="meta">
        <div id="tag" class="ui labels">
        <a class="ui label" id="time_ago">Sun Jan 20 2019 20:49:42 GMT+0800 (GMT+08:00)</a>
        <a class="ui label">I Want To Talk</a>
<a class="ui label">futures</a>
        
        </div>
    </header>
            <article>
            <p>sorry for my English. if you could not understand what I talk just point it out.
<br>
I am currently try to figure out how task::current works.
<br>
after digging some source code. I think I understand the call stack of task::current but still sth confuse me like the title. 
there is something I found out, correct me if I was wrong.  </p>
<p>current use a function called get_ptr to get a pointer of BorrowedTask.the BorrowedTask  is the current task.
<br>
source code under blow  </p>
<pre class="hlcode"><code><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">current</span></span>() -&gt; Task {
 with(|borrowed| {
 <span class="hljs-keyword">let</span> unpark = borrowed.unpark.to_owned();
 <span class="hljs-keyword">let</span> events = borrowed.events.to_owned();

        Task {
            id: borrowed.id,
            unpark: unpark,
            events: events,
        }
    })
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">with</span></span>&lt;F: <span class="hljs-built_in">FnOnce</span>(&amp;BorrowedTask) -&gt; R, R&gt;(f: F) -&gt; R {
 <span class="hljs-keyword">unsafe</span> {
 <span class="hljs-keyword">let</span> task = get_ptr().expect(<span class="hljs-string">"no Task is currently running"</span>);
 <span class="hljs-built_in">assert!</span>(!task.is_null(), <span class="hljs-string">"no Task is currently running"</span>);
 f(&amp;*(task <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> BorrowedTask))
    }
}

thread_local!(<span class="hljs-keyword">static</span> CURRENT_TASK: Cell&lt;*<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>&gt; = Cell::new(ptr::null_mut()));

<span class="hljs-keyword">static</span> INIT: Once = ONCE_INIT;

<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_ptr</span></span>() -&gt; <span class="hljs-built_in">Option</span>&lt;*<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>&gt; {
 <span class="hljs-comment">// Since this condition will always return true when TLS task storage is</span>
 <span class="hljs-comment">// used (the default), the branch predictor will be able to optimize the</span>
 <span class="hljs-comment">// branching and a dynamic dispatch will be avoided, which makes the</span>
 <span class="hljs-comment">// compiler happier.</span>
 <span class="hljs-keyword">if</span> core::is_get_ptr(<span class="hljs-number">0x1</span>) {
        <span class="hljs-literal">Some</span>(CURRENT_TASK.with(|c| c.get()))
    } <span class="hljs-keyword">else</span> {
        core::get_ptr()
    }
}<code></pre>
<p>so the question is who and when to set/update/init the CURRENT_TASK.
<br>
this is a function called set, seems the only way to do those stuff.</p>
<pre class="hlcode"><code> 
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">tls_slot</span></span>() -&gt; *<span class="hljs-keyword">const</span> Cell&lt;*<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>&gt; {
    CURRENT_TASK.with(|c| c <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _)
}

<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set</span></span>&lt;<span class="hljs-symbol">'a</span>, F, R&gt;(task: &amp;BorrowedTask&lt;<span class="hljs-symbol">'a</span>&gt;, f: F) -&gt; R
 <span class="hljs-keyword">where</span> F: <span class="hljs-built_in">FnOnce</span>() -&gt; R
{
 <span class="hljs-comment">// Lazily initialize the get / set ptrs</span>
 <span class="hljs-comment">//</span>
 <span class="hljs-comment">// Note that we won't actually use these functions ever, we'll instead be</span>
 <span class="hljs-comment">// testing the pointer's value elsewhere and calling our own functions.</span>
    INIT.call_once(|| <span class="hljs-keyword">unsafe</span> {
 <span class="hljs-keyword">let</span> get = mem::transmute::&lt;<span class="hljs-built_in">usize</span>, _&gt;(<span class="hljs-number">0x1</span>);
 <span class="hljs-keyword">let</span> set = mem::transmute::&lt;<span class="hljs-built_in">usize</span>, _&gt;(<span class="hljs-number">0x2</span>);
 init(get, set);
    });

 <span class="hljs-comment">// Same as above.</span>
 <span class="hljs-keyword">if</span> core::is_get_ptr(<span class="hljs-number">0x1</span>) {
 <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Reset</span></span>(*<span class="hljs-keyword">const</span> Cell&lt;*<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>&gt;, *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>);

 <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Reset {
            <span class="hljs-meta">#[inline]</span>
 <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
 <span class="hljs-keyword">unsafe</span> {
                    (*<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>).set(<span class="hljs-keyword">self</span>.<span class="hljs-number">1</span>);
                }
            }
        }

 <span class="hljs-keyword">unsafe</span> {
 <span class="hljs-keyword">let</span> slot = tls_slot();
 <span class="hljs-keyword">let</span> _reset = Reset(slot, (*slot).get());
            (*slot).set(task <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _ <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>);
 f()
        }
    } <span class="hljs-keyword">else</span> {
        core::set(task, f)
    }
}<code></pre>
<p>and then the question is who calls the set function.
<br>
and I find than I could not find whom to call set.
<br>
the calling chain seems broken.
<br>
after some search </p>
<blockquote><p> It is initialized by a reactor before polling a task and as discussed  above, may be overridden by specific futures within the task </p></blockquote>
<p>I found some word come from 
<a href="https://gist.github.com/Diggsey/6f924bf3f741bcdffd240faee102fe92">Looking into the Future</a></p>
<p>It seems to say that is there some code under tokio-reactor to called the set function, but after a search in tokio I still could not find anything about that.</p>
<p>please help me with that.</p>
            </article>
            </div>
            <body>
            <script src="..\..\..\common/script/fix.js"></script>
            </html>